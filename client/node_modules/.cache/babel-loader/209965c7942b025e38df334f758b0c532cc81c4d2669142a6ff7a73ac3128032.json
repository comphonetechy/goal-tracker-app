{"ast":null,"code":"/**\r\n * Javascript implementation of PKCS#12.\r\n *\r\n * @author Dave Longley\r\n * @author Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * The ASN.1 representation of PKCS#12 is as follows\r\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\r\n *\r\n * PFX ::= SEQUENCE {\r\n *   version  INTEGER {v3(3)}(v3,...),\r\n *   authSafe ContentInfo,\r\n *   macData  MacData OPTIONAL\r\n * }\r\n *\r\n * MacData ::= SEQUENCE {\r\n *   mac DigestInfo,\r\n *   macSalt OCTET STRING,\r\n *   iterations INTEGER DEFAULT 1\r\n * }\r\n * Note: The iterations default is for historical reasons and its use is\r\n * deprecated. A higher value, like 1024, is recommended.\r\n *\r\n * DigestInfo is defined in PKCS#7 as follows:\r\n *\r\n * DigestInfo ::= SEQUENCE {\r\n *   digestAlgorithm DigestAlgorithmIdentifier,\r\n *   digest Digest\r\n * }\r\n *\r\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r\n *\r\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r\n * for the algorithm, if any. In the case of SHA1 there is none.\r\n *\r\n * AlgorithmIdentifer ::= SEQUENCE {\r\n *    algorithm OBJECT IDENTIFIER,\r\n *    parameters ANY DEFINED BY algorithm OPTIONAL\r\n * }\r\n *\r\n * Digest ::= OCTET STRING\r\n *\r\n *\r\n * ContentInfo ::= SEQUENCE {\r\n *   contentType ContentType,\r\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\r\n * }\r\n *\r\n * ContentType ::= OBJECT IDENTIFIER\r\n *\r\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\r\n * -- Data if unencrypted\r\n * -- EncryptedData if password-encrypted\r\n * -- EnvelopedData if public key-encrypted\r\n *\r\n *\r\n * SafeContents ::= SEQUENCE OF SafeBag\r\n *\r\n * SafeBag ::= SEQUENCE {\r\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\r\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\r\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\r\n * }\r\n *\r\n * PKCS12Attribute ::= SEQUENCE {\r\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\r\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\r\n * } -- This type is compatible with the X.500 type 'Attribute'\r\n *\r\n * PKCS12AttrSet ATTRIBUTE ::= {\r\n *   friendlyName | -- from PKCS #9\r\n *   localKeyId, -- from PKCS #9\r\n *   ... -- Other attributes are allowed\r\n * }\r\n *\r\n * CertBag ::= SEQUENCE {\r\n *   certId    BAG-TYPE.&id   ({CertTypes}),\r\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\r\n * }\r\n *\r\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\r\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\r\n *\r\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\r\n * -- Base64-encoded SDSI certificate stored in IA5String\r\n *\r\n * CertTypes BAG-TYPE ::= {\r\n *   x509Certificate |\r\n *   sdsiCertificate,\r\n *   ... -- For future extensions\r\n * }\r\n */\nvar forge = require('./forge');\nrequire('./asn1');\nrequire('./hmac');\nrequire('./oids');\nrequire('./pkcs7asn1');\nrequire('./pbe');\nrequire('./random');\nrequire('./rsa');\nrequire('./sha1');\nrequire('./util');\nrequire('./x509');\n\n// shortcut for asn.1 & PKI API\nvar asn1 = forge.asn1;\nvar pki = forge.pki;\n\n// shortcut for PKCS#12 API\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  // a ContentInfo\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'content'\n  }]\n};\nvar pfxValidator = {\n  name: 'PFX',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PFX.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }, contentInfoValidator, {\n    name: 'PFX.macData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'mac',\n    value: [{\n      name: 'PFX.macData.mac',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      // DigestInfo\n      constructed: true,\n      value: [{\n        name: 'PFX.macData.mac.digestAlgorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        // DigestAlgorithmIdentifier\n        constructed: true,\n        value: [{\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'macAlgorithm'\n        }, {\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\n          optional: true,\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: 'macAlgorithmParameters'\n        }]\n      }, {\n        name: 'PFX.macData.mac.digest',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'macDigest'\n      }]\n    }, {\n      name: 'PFX.macData.macSalt',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'macSalt'\n    }, {\n      name: 'PFX.macData.iterations',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      optional: true,\n      capture: 'macIterations'\n    }]\n  }]\n};\nvar safeBagValidator = {\n  name: 'SafeBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SafeBag.bagId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'bagId'\n  }, {\n    name: 'SafeBag.bagValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'bagValue'\n  }, {\n    name: 'SafeBag.bagAttributes',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    optional: true,\n    capture: 'bagAttributes'\n  }]\n};\nvar attributeValidator = {\n  name: 'Attribute',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Attribute.attrId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'oid'\n  }, {\n    name: 'Attribute.attrValues',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    capture: 'values'\n  }]\n};\nvar certBagValidator = {\n  name: 'CertBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'CertBag.certId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'certId'\n  }, {\n    name: 'CertBag.certValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    /* So far we only support X.509 certificates (which are wrapped in\r\n       an OCTET STRING, hence hard code that here). */\n    value: [{\n      name: 'CertBag.certValue[0]',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.OCTETSTRING,\n      constructed: false,\n      capture: 'cert'\n    }]\n  }]\n};\n\n/**\r\n * Search SafeContents structure for bags with matching attributes.\r\n *\r\n * The search can optionally be narrowed by a certain bag type.\r\n *\r\n * @param safeContents the SafeContents structure to search in.\r\n * @param attrName the name of the attribute to compare against.\r\n * @param attrValue the attribute value to search for.\r\n * @param [bagType] bag type to narrow search by.\r\n *\r\n * @return an array of matching bags.\r\n */\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n  var result = [];\n  for (var i = 0; i < safeContents.length; i++) {\n    for (var j = 0; j < safeContents[i].safeBags.length; j++) {\n      var bag = safeContents[i].safeBags[j];\n      if (bagType !== undefined && bag.type !== bagType) {\n        continue;\n      }\n      // only filter by bag type, no attribute specified\n      if (attrName === null) {\n        result.push(bag);\n        continue;\n      }\n      if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) {\n        result.push(bag);\n      }\n    }\n  }\n  return result;\n}\n\n/**\r\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\r\n *\r\n * @param obj The PKCS#12 PFX in ASN.1 notation.\r\n * @param strict true to use strict DER decoding, false not to (default: true).\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return PKCS#12 PFX object.\r\n */\np12.pkcs12FromAsn1 = function (obj, strict, password) {\n  // handle args\n  if (typeof strict === 'string') {\n    password = strict;\n    strict = true;\n  } else if (strict === undefined) {\n    strict = true;\n  }\n\n  // validate PFX and capture data\n  var capture = {};\n  var errors = [];\n  if (!asn1.validate(obj, pfxValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#12 PFX. ' + 'ASN.1 object is not an PKCS#12 PFX.');\n    error.errors = error;\n    throw error;\n  }\n  var pfx = {\n    version: capture.version.charCodeAt(0),\n    safeContents: [],\n    /**\r\n     * Gets bags with matching attributes.\r\n     *\r\n     * @param filter the attributes to filter by:\r\n     *          [localKeyId] the localKeyId to search for.\r\n     *          [localKeyIdHex] the localKeyId in hex to search for.\r\n     *          [friendlyName] the friendly name to search for.\r\n     *          [bagType] bag type to narrow each attribute search by.\r\n     *\r\n     * @return a map of attribute type to an array of matching bags or, if no\r\n     *           attribute was given but a bag type, the map key will be the\r\n     *           bag type.\r\n     */\n    getBags: function (filter) {\n      var rval = {};\n      var localKeyId;\n      if ('localKeyId' in filter) {\n        localKeyId = filter.localKeyId;\n      } else if ('localKeyIdHex' in filter) {\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n      }\n\n      // filter on bagType only\n      if (localKeyId === undefined && !('friendlyName' in filter) && 'bagType' in filter) {\n        rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);\n      }\n      if (localKeyId !== undefined) {\n        rval.localKeyId = _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, filter.bagType);\n      }\n      if ('friendlyName' in filter) {\n        rval.friendlyName = _getBagsByAttribute(pfx.safeContents, 'friendlyName', filter.friendlyName, filter.bagType);\n      }\n      return rval;\n    },\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching friendlyName attribute.\r\n     *\r\n     * @param friendlyName the friendly name to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching friendlyName attribute.\r\n     */\n    getBagsByFriendlyName: function (friendlyName, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'friendlyName', friendlyName, bagType);\n    },\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching localKeyId attribute.\r\n     *\r\n     * @param localKeyId the localKeyId to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching localKeyId attribute.\r\n     */\n    getBagsByLocalKeyId: function (localKeyId, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, bagType);\n    }\n  };\n  if (capture.version.charCodeAt(0) !== 3) {\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\n    error.version = capture.version.charCodeAt(0);\n    throw error;\n  }\n  if (asn1.derToOid(capture.contentType) !== pki.oids.data) {\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\n    error.oid = asn1.derToOid(capture.contentType);\n    throw error;\n  }\n  var data = capture.content.value[0];\n  if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\n  }\n  data = _decodePkcs7Data(data);\n\n  // check for MAC\n  if (capture.mac) {\n    var md = null;\n    var macKeyBytes = 0;\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n    switch (macAlgorithm) {\n      case pki.oids.sha1:\n        md = forge.md.sha1.create();\n        macKeyBytes = 20;\n        break;\n      case pki.oids.sha256:\n        md = forge.md.sha256.create();\n        macKeyBytes = 32;\n        break;\n      case pki.oids.sha384:\n        md = forge.md.sha384.create();\n        macKeyBytes = 48;\n        break;\n      case pki.oids.sha512:\n        md = forge.md.sha512.create();\n        macKeyBytes = 64;\n        break;\n      case pki.oids.md5:\n        md = forge.md.md5.create();\n        macKeyBytes = 16;\n        break;\n    }\n    if (md === null) {\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\n    }\n\n    // verify MAC (iterations default to 1)\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n    var macIterations = 'macIterations' in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;\n    var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);\n    var mac = forge.hmac.create();\n    mac.start(md, macKey);\n    mac.update(data.value);\n    var macValue = mac.getMac();\n    if (macValue.getBytes() !== capture.macDigest) {\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\n    }\n  } else if (Array.isArray(obj.value) && obj.value.length > 2) {\n    /* This is pfx data that should have mac and verify macDigest */\n    throw new Error('Invalid PKCS#12. macData field present but MAC was not validated.');\n  }\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n  return pfx;\n};\n\n/**\r\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\r\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\r\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\r\n * function transforms this corner-case into the usual simple,\r\n * non-composed/constructed OCTET STRING.\r\n *\r\n * This function may be moved to ASN.1 at some point to better deal with\r\n * more BER-encoding issues, should they arise.\r\n *\r\n * @param data the ASN.1 Data object to transform.\r\n */\nfunction _decodePkcs7Data(data) {\n  // handle special case of \"chunked\" data content: an octet string composed\n  // of other octet strings\n  if (data.composed || data.constructed) {\n    var value = forge.util.createBuffer();\n    for (var i = 0; i < data.value.length; ++i) {\n      value.putBytes(data.value[i].value);\n    }\n    data.composed = data.constructed = false;\n    data.value = value.getBytes();\n  }\n  return data;\n}\n\n/**\r\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\r\n *\r\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\r\n *\r\n * @param pfx The PKCS#12 PFX object to fill.\r\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n */\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n  authSafe = asn1.fromDer(authSafe, strict); /* actually it's BER encoded */\n\n  if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' + 'SEQUENCE OF ContentInfo');\n  }\n  for (var i = 0; i < authSafe.value.length; i++) {\n    var contentInfo = authSafe.value[i];\n\n    // validate contentInfo and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n      var error = new Error('Cannot read ContentInfo.');\n      error.errors = errors;\n      throw error;\n    }\n    var obj = {\n      encrypted: false\n    };\n    var safeContents = null;\n    var data = capture.content.value[0];\n    switch (asn1.derToOid(capture.contentType)) {\n      case pki.oids.data:\n        if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n          throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\n        }\n        safeContents = _decodePkcs7Data(data).value;\n        break;\n      case pki.oids.encryptedData:\n        safeContents = _decryptSafeContents(data, password);\n        obj.encrypted = true;\n        break;\n      default:\n        var error = new Error('Unsupported PKCS#12 contentType.');\n        error.contentType = asn1.derToOid(capture.contentType);\n        throw error;\n    }\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n    pfx.safeContents.push(obj);\n  }\n}\n\n/**\r\n * Decrypt PKCS#7 EncryptedData structure.\r\n *\r\n * @param data ASN.1 encoded EncryptedContentInfo object.\r\n * @param password The user-provided password.\r\n *\r\n * @return The decrypted SafeContents (ASN.1 object).\r\n */\nfunction _decryptSafeContents(data, password) {\n  var capture = {};\n  var errors = [];\n  if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n    var error = new Error('Cannot read EncryptedContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n  var oid = asn1.derToOid(capture.contentType);\n  if (oid !== pki.oids.data) {\n    var error = new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');\n    error.oid = oid;\n    throw error;\n  }\n\n  // get cipher\n  oid = asn1.derToOid(capture.encAlgorithm);\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\n\n  // get encrypted data\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n  cipher.update(encrypted);\n  if (!cipher.finish()) {\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\n  }\n  return cipher.output.getBytes();\n}\n\n/**\r\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\r\n *\r\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\r\n *\r\n * @param {String} safeContents BER-encoded safeContents.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return {Array} Array of Bag objects.\r\n */\nfunction _decodeSafeContents(safeContents, strict, password) {\n  // if strict and no safe contents, return empty safes\n  if (!strict && safeContents.length === 0) {\n    return [];\n  }\n\n  // actually it's BER-encoded\n  safeContents = asn1.fromDer(safeContents, strict);\n  if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {\n    throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\n  }\n  var res = [];\n  for (var i = 0; i < safeContents.value.length; i++) {\n    var safeBag = safeContents.value[i];\n\n    // validate SafeBag and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n      var error = new Error('Cannot read SafeBag.');\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Create bag object and push to result array. */\n    var bag = {\n      type: asn1.derToOid(capture.bagId),\n      attributes: _decodeBagAttributes(capture.bagAttributes)\n    };\n    res.push(bag);\n    var validator, decoder;\n    var bagAsn1 = capture.bagValue.value[0];\n    switch (bag.type) {\n      case pki.oids.pkcs8ShroudedKeyBag:\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\r\n           Afterwards we can handle it like a keyBag,\r\n           which is a PrivateKeyInfo. */\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n        if (bagAsn1 === null) {\n          throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\n        }\n\n      /* fall through */\n      case pki.oids.keyBag:\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\r\n           PKI module, hence we don't have to do validation/capturing here,\r\n           just pass what we already got. */\n        try {\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\n        } catch (e) {\n          // ignore unknown key type, pass asn1 value\n          bag.key = null;\n          bag.asn1 = bagAsn1;\n        }\n        continue;\n      /* Nothing more to do. */\n\n      case pki.oids.certBag:\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\r\n           Therefore put the SafeBag content through another validator to\r\n           capture the fields.  Afterwards check & store the results. */\n        validator = certBagValidator;\n        decoder = function () {\n          if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n            var error = new Error('Unsupported certificate type, only X.509 supported.');\n            error.oid = asn1.derToOid(capture.certId);\n            throw error;\n          }\n\n          // true=produce cert hash\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\n          try {\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\n          } catch (e) {\n            // ignore unknown cert type, pass asn1 value\n            bag.cert = null;\n            bag.asn1 = certAsn1;\n          }\n        };\n        break;\n      default:\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\n        error.oid = bag.type;\n        throw error;\n    }\n\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\n    if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) {\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Call decoder function from above to store the results. */\n    decoder();\n  }\n  return res;\n}\n\n/**\r\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\r\n *\r\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\r\n *\r\n * @return the decoded attributes.\r\n */\nfunction _decodeBagAttributes(attributes) {\n  var decodedAttrs = {};\n  if (attributes !== undefined) {\n    for (var i = 0; i < attributes.length; ++i) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\n        error.errors = errors;\n        throw error;\n      }\n      var oid = asn1.derToOid(capture.oid);\n      if (pki.oids[oid] === undefined) {\n        // unsupported attribute type, ignore.\n        continue;\n      }\n      decodedAttrs[pki.oids[oid]] = [];\n      for (var j = 0; j < capture.values.length; ++j) {\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n      }\n    }\n  }\n  return decodedAttrs;\n}\n\n/**\r\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\r\n * password is provided then the private key will be encrypted.\r\n *\r\n * An entire certificate chain may also be included. To do this, pass\r\n * an array for the \"cert\" parameter where the first certificate is\r\n * the one that is paired with the private key and each subsequent one\r\n * verifies the previous one. The certificates may be in PEM format or\r\n * have been already parsed by Forge.\r\n *\r\n * @todo implement password-based-encryption for the whole package\r\n *\r\n * @param key the private key.\r\n * @param cert the certificate (may be an array of certificates in order\r\n *          to specify a certificate chain).\r\n * @param password the password to use, null for none.\r\n * @param options:\r\n *          algorithm the encryption algorithm to use\r\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r\n *          count the iteration count to use.\r\n *          saltSize the salt size to use.\r\n *          useMac true to include a MAC, false not to, defaults to true.\r\n *          localKeyId the local key ID to use, in hex.\r\n *          friendlyName the friendly name to use.\r\n *          generateLocalKeyId true to generate a random local key ID,\r\n *            false not to, defaults to true.\r\n *\r\n * @return the PKCS#12 PFX ASN.1 object.\r\n */\np12.toPkcs12Asn1 = function (key, cert, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\n  if (!('useMac' in options)) {\n    options.useMac = true;\n  }\n  if (!('localKeyId' in options)) {\n    options.localKeyId = null;\n  }\n  if (!('generateLocalKeyId' in options)) {\n    options.generateLocalKeyId = true;\n  }\n  var localKeyId = options.localKeyId;\n  var bagAttrs;\n  if (localKeyId !== null) {\n    localKeyId = forge.util.hexToBytes(localKeyId);\n  } else if (options.generateLocalKeyId) {\n    // use SHA-1 of paired cert, if available\n    if (cert) {\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n      if (typeof pairedCert === 'string') {\n        pairedCert = pki.certificateFromPem(pairedCert);\n      }\n      var sha1 = forge.md.sha1.create();\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n      localKeyId = sha1.digest().getBytes();\n    } else {\n      // FIXME: consider using SHA-1 of public key (which can be generated\n      // from private key components), see: cert.generateSubjectKeyIdentifier\n      // generate random bytes\n      localKeyId = forge.random.getBytes(20);\n    }\n  }\n  var attrs = [];\n  if (localKeyId !== null) {\n    attrs.push(\n    // localKeyID\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()),\n    // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));\n  }\n  if ('friendlyName' in options) {\n    attrs.push(\n    // friendlyName\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()),\n    // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));\n  }\n  if (attrs.length > 0) {\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n  }\n\n  // collect contents for AuthenticatedSafe\n  var contents = [];\n\n  // create safe bag(s) for certificate chain\n  var chain = [];\n  if (cert !== null) {\n    if (forge.util.isArray(cert)) {\n      chain = cert;\n    } else {\n      chain = [cert];\n    }\n  }\n  var certSafeBags = [];\n  for (var i = 0; i < chain.length; ++i) {\n    // convert cert from PEM as necessary\n    cert = chain[i];\n    if (typeof cert === 'string') {\n      cert = pki.certificateFromPem(cert);\n    }\n\n    // SafeBag\n    var certBagAttrs = i === 0 ? bagAttrs : undefined;\n    var certAsn1 = pki.certificateToAsn1(cert);\n    var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // bagId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()),\n    // bagValue\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n    // CertBag\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // certId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\n    // certValue (x509Certificate)\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]),\n    // bagAttributes (OPTIONAL)\n    certBagAttrs]);\n    certSafeBags.push(certSafeBag);\n  }\n  if (certSafeBags.length > 0) {\n    // SafeContents\n    var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\n\n    // ContentInfo\n    var certCI =\n    // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n    // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()),\n    // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);\n    contents.push(certCI);\n  }\n\n  // create safe contents for private key\n  var keyBag = null;\n  if (key !== null) {\n    // SafeBag\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n    if (password === null) {\n      // no encryption\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()),\n      // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n      // PrivateKeyInfo\n      pkAsn1]),\n      // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    } else {\n      // encrypted PrivateKeyInfo\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\n      // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n      // EncryptedPrivateKeyInfo\n      pki.encryptPrivateKeyInfo(pkAsn1, password, options)]),\n      // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    }\n\n    // SafeContents\n    var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\n\n    // ContentInfo\n    var keyCI =\n    // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n    // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()),\n    // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);\n    contents.push(keyCI);\n  }\n\n  // create AuthenticatedSafe by stringing together the contents\n  var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n  var macData;\n  if (options.useMac) {\n    // MacData\n    var sha1 = forge.md.sha1.create();\n    var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));\n    var count = options.count;\n    // 160-bit key\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\n    var mac = forge.hmac.create();\n    mac.start(sha1, key);\n    mac.update(asn1.toDer(safe).getBytes());\n    var macValue = mac.getMac();\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // mac DigestInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // digestAlgorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // algorithm = SHA-1\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()),\n    // parameters = Null\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]),\n    // digest\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]),\n    // macSalt OCTET STRING\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\n    // iterations INTEGER (XXX: Only support count < 65536)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())]);\n  }\n\n  // PFX\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n  // version (3)\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()),\n  // PKCS#7 ContentInfo\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n  // contentType\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n  // OID for the content type is 'data'\n  asn1.oidToDer(pki.oids.data).getBytes()),\n  // content\n  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]), macData]);\n};\n\n/**\r\n * Derives a PKCS#12 key.\r\n *\r\n * @param password the password to derive the key material from, null or\r\n *          undefined for none.\r\n * @param salt the salt, as a ByteBuffer, to use.\r\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r\n * @param iter the iteration count.\r\n * @param n the number of bytes to derive from the password.\r\n * @param md the message digest to use, defaults to SHA-1.\r\n *\r\n * @return a ByteBuffer with the bytes derived from the password.\r\n */\np12.generateKey = forge.pbe.generatePkcs12Key;","map":{"version":3,"names":["forge","require","asn1","pki","p12","module","exports","pkcs12","contentInfoValidator","name","tagClass","Class","UNIVERSAL","type","Type","SEQUENCE","constructed","value","OID","capture","CONTEXT_SPECIFIC","captureAsn1","pfxValidator","INTEGER","optional","OCTETSTRING","safeBagValidator","SET","attributeValidator","certBagValidator","_getBagsByAttribute","safeContents","attrName","attrValue","bagType","result","i","length","j","safeBags","bag","undefined","push","attributes","indexOf","pkcs12FromAsn1","obj","strict","password","errors","validate","error","Error","pfx","version","charCodeAt","getBags","filter","rval","localKeyId","util","hexToBytes","localKeyIdHex","friendlyName","getBagsByFriendlyName","getBagsByLocalKeyId","derToOid","contentType","oids","data","oid","content","_decodePkcs7Data","mac","md","macKeyBytes","macAlgorithm","sha1","create","sha256","sha384","sha512","md5","macSalt","ByteBuffer","macIterations","parseInt","bytesToHex","macKey","generateKey","hmac","start","update","macValue","getMac","getBytes","macDigest","Array","isArray","_decodeAuthenticatedSafe","composed","createBuffer","putBytes","authSafe","fromDer","contentInfo","encrypted","encryptedData","_decryptSafeContents","_decodeSafeContents","pkcs7","encryptedDataValidator","encAlgorithm","cipher","pbe","getCipher","encParameter","encryptedContentAsn1","finish","output","res","safeBag","bagId","_decodeBagAttributes","bagAttributes","validator","decoder","bagAsn1","bagValue","pkcs8ShroudedKeyBag","decryptPrivateKeyInfo","keyBag","key","privateKeyFromAsn1","e","certBag","certId","x509Certificate","certAsn1","cert","certificateFromAsn1","decodedAttrs","values","toPkcs12Asn1","options","saltSize","count","algorithm","useMac","generateLocalKeyId","bagAttrs","pairedCert","certificateFromPem","toDer","certificateToAsn1","digest","random","attrs","oidToDer","BMPSTRING","contents","chain","certSafeBags","certBagAttrs","certSafeBag","certSafeContents","certCI","pkAsn1","wrapRsaPrivateKey","privateKeyToAsn1","encryptPrivateKeyInfo","keySafeContents","keyCI","safe","macData","NULL","integerToDer","generatePkcs12Key"],"sources":["C:/Users/PROGRAMMER/Desktop/goal tracker app clone/goal-tracker-app/client/node_modules/node-forge/lib/pkcs12.js"],"sourcesContent":["/**\r\n * Javascript implementation of PKCS#12.\r\n *\r\n * @author Dave Longley\r\n * @author Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * The ASN.1 representation of PKCS#12 is as follows\r\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\r\n *\r\n * PFX ::= SEQUENCE {\r\n *   version  INTEGER {v3(3)}(v3,...),\r\n *   authSafe ContentInfo,\r\n *   macData  MacData OPTIONAL\r\n * }\r\n *\r\n * MacData ::= SEQUENCE {\r\n *   mac DigestInfo,\r\n *   macSalt OCTET STRING,\r\n *   iterations INTEGER DEFAULT 1\r\n * }\r\n * Note: The iterations default is for historical reasons and its use is\r\n * deprecated. A higher value, like 1024, is recommended.\r\n *\r\n * DigestInfo is defined in PKCS#7 as follows:\r\n *\r\n * DigestInfo ::= SEQUENCE {\r\n *   digestAlgorithm DigestAlgorithmIdentifier,\r\n *   digest Digest\r\n * }\r\n *\r\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r\n *\r\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r\n * for the algorithm, if any. In the case of SHA1 there is none.\r\n *\r\n * AlgorithmIdentifer ::= SEQUENCE {\r\n *    algorithm OBJECT IDENTIFIER,\r\n *    parameters ANY DEFINED BY algorithm OPTIONAL\r\n * }\r\n *\r\n * Digest ::= OCTET STRING\r\n *\r\n *\r\n * ContentInfo ::= SEQUENCE {\r\n *   contentType ContentType,\r\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\r\n * }\r\n *\r\n * ContentType ::= OBJECT IDENTIFIER\r\n *\r\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\r\n * -- Data if unencrypted\r\n * -- EncryptedData if password-encrypted\r\n * -- EnvelopedData if public key-encrypted\r\n *\r\n *\r\n * SafeContents ::= SEQUENCE OF SafeBag\r\n *\r\n * SafeBag ::= SEQUENCE {\r\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\r\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\r\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\r\n * }\r\n *\r\n * PKCS12Attribute ::= SEQUENCE {\r\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\r\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\r\n * } -- This type is compatible with the X.500 type 'Attribute'\r\n *\r\n * PKCS12AttrSet ATTRIBUTE ::= {\r\n *   friendlyName | -- from PKCS #9\r\n *   localKeyId, -- from PKCS #9\r\n *   ... -- Other attributes are allowed\r\n * }\r\n *\r\n * CertBag ::= SEQUENCE {\r\n *   certId    BAG-TYPE.&id   ({CertTypes}),\r\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\r\n * }\r\n *\r\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\r\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\r\n *\r\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\r\n * -- Base64-encoded SDSI certificate stored in IA5String\r\n *\r\n * CertTypes BAG-TYPE ::= {\r\n *   x509Certificate |\r\n *   sdsiCertificate,\r\n *   ... -- For future extensions\r\n * }\r\n */\r\nvar forge = require('./forge');\r\nrequire('./asn1');\r\nrequire('./hmac');\r\nrequire('./oids');\r\nrequire('./pkcs7asn1');\r\nrequire('./pbe');\r\nrequire('./random');\r\nrequire('./rsa');\r\nrequire('./sha1');\r\nrequire('./util');\r\nrequire('./x509');\r\n\r\n// shortcut for asn.1 & PKI API\r\nvar asn1 = forge.asn1;\r\nvar pki = forge.pki;\r\n\r\n// shortcut for PKCS#12 API\r\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\r\n\r\nvar contentInfoValidator = {\r\n  name: 'ContentInfo',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,  // a ContentInfo\r\n  constructed: true,\r\n  value: [{\r\n    name: 'ContentInfo.contentType',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.OID,\r\n    constructed: false,\r\n    capture: 'contentType'\r\n  }, {\r\n    name: 'ContentInfo.content',\r\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r\n    constructed: true,\r\n    captureAsn1: 'content'\r\n  }]\r\n};\r\n\r\nvar pfxValidator = {\r\n  name: 'PFX',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,\r\n  constructed: true,\r\n  value: [{\r\n    name: 'PFX.version',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.INTEGER,\r\n    constructed: false,\r\n    capture: 'version'\r\n  },\r\n  contentInfoValidator, {\r\n    name: 'PFX.macData',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.SEQUENCE,\r\n    constructed: true,\r\n    optional: true,\r\n    captureAsn1: 'mac',\r\n    value: [{\r\n      name: 'PFX.macData.mac',\r\n      tagClass: asn1.Class.UNIVERSAL,\r\n      type: asn1.Type.SEQUENCE,  // DigestInfo\r\n      constructed: true,\r\n      value: [{\r\n        name: 'PFX.macData.mac.digestAlgorithm',\r\n        tagClass: asn1.Class.UNIVERSAL,\r\n        type: asn1.Type.SEQUENCE,  // DigestAlgorithmIdentifier\r\n        constructed: true,\r\n        value: [{\r\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\r\n          tagClass: asn1.Class.UNIVERSAL,\r\n          type: asn1.Type.OID,\r\n          constructed: false,\r\n          capture: 'macAlgorithm'\r\n        }, {\r\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\r\n          optional: true,\r\n          tagClass: asn1.Class.UNIVERSAL,\r\n          captureAsn1: 'macAlgorithmParameters'\r\n        }]\r\n      }, {\r\n        name: 'PFX.macData.mac.digest',\r\n        tagClass: asn1.Class.UNIVERSAL,\r\n        type: asn1.Type.OCTETSTRING,\r\n        constructed: false,\r\n        capture: 'macDigest'\r\n      }]\r\n    }, {\r\n      name: 'PFX.macData.macSalt',\r\n      tagClass: asn1.Class.UNIVERSAL,\r\n      type: asn1.Type.OCTETSTRING,\r\n      constructed: false,\r\n      capture: 'macSalt'\r\n    }, {\r\n      name: 'PFX.macData.iterations',\r\n      tagClass: asn1.Class.UNIVERSAL,\r\n      type: asn1.Type.INTEGER,\r\n      constructed: false,\r\n      optional: true,\r\n      capture: 'macIterations'\r\n    }]\r\n  }]\r\n};\r\n\r\nvar safeBagValidator = {\r\n  name: 'SafeBag',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,\r\n  constructed: true,\r\n  value: [{\r\n    name: 'SafeBag.bagId',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.OID,\r\n    constructed: false,\r\n    capture: 'bagId'\r\n  }, {\r\n    name: 'SafeBag.bagValue',\r\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r\n    constructed: true,\r\n    captureAsn1: 'bagValue'\r\n  }, {\r\n    name: 'SafeBag.bagAttributes',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.SET,\r\n    constructed: true,\r\n    optional: true,\r\n    capture: 'bagAttributes'\r\n  }]\r\n};\r\n\r\nvar attributeValidator = {\r\n  name: 'Attribute',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,\r\n  constructed: true,\r\n  value: [{\r\n    name: 'Attribute.attrId',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.OID,\r\n    constructed: false,\r\n    capture: 'oid'\r\n  }, {\r\n    name: 'Attribute.attrValues',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.SET,\r\n    constructed: true,\r\n    capture: 'values'\r\n  }]\r\n};\r\n\r\nvar certBagValidator = {\r\n  name: 'CertBag',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,\r\n  constructed: true,\r\n  value: [{\r\n    name: 'CertBag.certId',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.OID,\r\n    constructed: false,\r\n    capture: 'certId'\r\n  }, {\r\n    name: 'CertBag.certValue',\r\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r\n    constructed: true,\r\n    /* So far we only support X.509 certificates (which are wrapped in\r\n       an OCTET STRING, hence hard code that here). */\r\n    value: [{\r\n      name: 'CertBag.certValue[0]',\r\n      tagClass: asn1.Class.UNIVERSAL,\r\n      type: asn1.Class.OCTETSTRING,\r\n      constructed: false,\r\n      capture: 'cert'\r\n    }]\r\n  }]\r\n};\r\n\r\n/**\r\n * Search SafeContents structure for bags with matching attributes.\r\n *\r\n * The search can optionally be narrowed by a certain bag type.\r\n *\r\n * @param safeContents the SafeContents structure to search in.\r\n * @param attrName the name of the attribute to compare against.\r\n * @param attrValue the attribute value to search for.\r\n * @param [bagType] bag type to narrow search by.\r\n *\r\n * @return an array of matching bags.\r\n */\r\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\r\n  var result = [];\r\n\r\n  for(var i = 0; i < safeContents.length; i++) {\r\n    for(var j = 0; j < safeContents[i].safeBags.length; j++) {\r\n      var bag = safeContents[i].safeBags[j];\r\n      if(bagType !== undefined && bag.type !== bagType) {\r\n        continue;\r\n      }\r\n      // only filter by bag type, no attribute specified\r\n      if(attrName === null) {\r\n        result.push(bag);\r\n        continue;\r\n      }\r\n      if(bag.attributes[attrName] !== undefined &&\r\n        bag.attributes[attrName].indexOf(attrValue) >= 0) {\r\n        result.push(bag);\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\r\n *\r\n * @param obj The PKCS#12 PFX in ASN.1 notation.\r\n * @param strict true to use strict DER decoding, false not to (default: true).\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return PKCS#12 PFX object.\r\n */\r\np12.pkcs12FromAsn1 = function(obj, strict, password) {\r\n  // handle args\r\n  if(typeof strict === 'string') {\r\n    password = strict;\r\n    strict = true;\r\n  } else if(strict === undefined) {\r\n    strict = true;\r\n  }\r\n\r\n  // validate PFX and capture data\r\n  var capture = {};\r\n  var errors = [];\r\n  if(!asn1.validate(obj, pfxValidator, capture, errors)) {\r\n    var error = new Error('Cannot read PKCS#12 PFX. ' +\r\n      'ASN.1 object is not an PKCS#12 PFX.');\r\n    error.errors = error;\r\n    throw error;\r\n  }\r\n\r\n  var pfx = {\r\n    version: capture.version.charCodeAt(0),\r\n    safeContents: [],\r\n\r\n    /**\r\n     * Gets bags with matching attributes.\r\n     *\r\n     * @param filter the attributes to filter by:\r\n     *          [localKeyId] the localKeyId to search for.\r\n     *          [localKeyIdHex] the localKeyId in hex to search for.\r\n     *          [friendlyName] the friendly name to search for.\r\n     *          [bagType] bag type to narrow each attribute search by.\r\n     *\r\n     * @return a map of attribute type to an array of matching bags or, if no\r\n     *           attribute was given but a bag type, the map key will be the\r\n     *           bag type.\r\n     */\r\n    getBags: function(filter) {\r\n      var rval = {};\r\n\r\n      var localKeyId;\r\n      if('localKeyId' in filter) {\r\n        localKeyId = filter.localKeyId;\r\n      } else if('localKeyIdHex' in filter) {\r\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\r\n      }\r\n\r\n      // filter on bagType only\r\n      if(localKeyId === undefined && !('friendlyName' in filter) &&\r\n        'bagType' in filter) {\r\n        rval[filter.bagType] = _getBagsByAttribute(\r\n          pfx.safeContents, null, null, filter.bagType);\r\n      }\r\n\r\n      if(localKeyId !== undefined) {\r\n        rval.localKeyId = _getBagsByAttribute(\r\n          pfx.safeContents, 'localKeyId',\r\n          localKeyId, filter.bagType);\r\n      }\r\n      if('friendlyName' in filter) {\r\n        rval.friendlyName = _getBagsByAttribute(\r\n          pfx.safeContents, 'friendlyName',\r\n          filter.friendlyName, filter.bagType);\r\n      }\r\n\r\n      return rval;\r\n    },\r\n\r\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching friendlyName attribute.\r\n     *\r\n     * @param friendlyName the friendly name to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching friendlyName attribute.\r\n     */\r\n    getBagsByFriendlyName: function(friendlyName, bagType) {\r\n      return _getBagsByAttribute(\r\n        pfx.safeContents, 'friendlyName', friendlyName, bagType);\r\n    },\r\n\r\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching localKeyId attribute.\r\n     *\r\n     * @param localKeyId the localKeyId to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching localKeyId attribute.\r\n     */\r\n    getBagsByLocalKeyId: function(localKeyId, bagType) {\r\n      return _getBagsByAttribute(\r\n        pfx.safeContents, 'localKeyId', localKeyId, bagType);\r\n    }\r\n  };\r\n\r\n  if(capture.version.charCodeAt(0) !== 3) {\r\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\r\n    error.version = capture.version.charCodeAt(0);\r\n    throw error;\r\n  }\r\n\r\n  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {\r\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\r\n    error.oid = asn1.derToOid(capture.contentType);\r\n    throw error;\r\n  }\r\n\r\n  var data = capture.content.value[0];\r\n  if(data.tagClass !== asn1.Class.UNIVERSAL ||\r\n     data.type !== asn1.Type.OCTETSTRING) {\r\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\r\n  }\r\n  data = _decodePkcs7Data(data);\r\n\r\n  // check for MAC\r\n  if(capture.mac) {\r\n    var md = null;\r\n    var macKeyBytes = 0;\r\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\r\n    switch(macAlgorithm) {\r\n    case pki.oids.sha1:\r\n      md = forge.md.sha1.create();\r\n      macKeyBytes = 20;\r\n      break;\r\n    case pki.oids.sha256:\r\n      md = forge.md.sha256.create();\r\n      macKeyBytes = 32;\r\n      break;\r\n    case pki.oids.sha384:\r\n      md = forge.md.sha384.create();\r\n      macKeyBytes = 48;\r\n      break;\r\n    case pki.oids.sha512:\r\n      md = forge.md.sha512.create();\r\n      macKeyBytes = 64;\r\n      break;\r\n    case pki.oids.md5:\r\n      md = forge.md.md5.create();\r\n      macKeyBytes = 16;\r\n      break;\r\n    }\r\n    if(md === null) {\r\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\r\n    }\r\n\r\n    // verify MAC (iterations default to 1)\r\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\r\n    var macIterations = (('macIterations' in capture) ?\r\n      parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);\r\n    var macKey = p12.generateKey(\r\n      password, macSalt, 3, macIterations, macKeyBytes, md);\r\n    var mac = forge.hmac.create();\r\n    mac.start(md, macKey);\r\n    mac.update(data.value);\r\n    var macValue = mac.getMac();\r\n    if(macValue.getBytes() !== capture.macDigest) {\r\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\r\n    }\r\n  } else if(Array.isArray(obj.value) && obj.value.length > 2) {\r\n    /* This is pfx data that should have mac and verify macDigest */\r\n    throw new Error('Invalid PKCS#12. macData field present but MAC was not validated.');\r\n  }\r\n\r\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\r\n  return pfx;\r\n};\r\n\r\n/**\r\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\r\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\r\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\r\n * function transforms this corner-case into the usual simple,\r\n * non-composed/constructed OCTET STRING.\r\n *\r\n * This function may be moved to ASN.1 at some point to better deal with\r\n * more BER-encoding issues, should they arise.\r\n *\r\n * @param data the ASN.1 Data object to transform.\r\n */\r\nfunction _decodePkcs7Data(data) {\r\n  // handle special case of \"chunked\" data content: an octet string composed\r\n  // of other octet strings\r\n  if(data.composed || data.constructed) {\r\n    var value = forge.util.createBuffer();\r\n    for(var i = 0; i < data.value.length; ++i) {\r\n      value.putBytes(data.value[i].value);\r\n    }\r\n    data.composed = data.constructed = false;\r\n    data.value = value.getBytes();\r\n  }\r\n  return data;\r\n}\r\n\r\n/**\r\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\r\n *\r\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\r\n *\r\n * @param pfx The PKCS#12 PFX object to fill.\r\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n */\r\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\r\n  authSafe = asn1.fromDer(authSafe, strict);  /* actually it's BER encoded */\r\n\r\n  if(authSafe.tagClass !== asn1.Class.UNIVERSAL ||\r\n     authSafe.type !== asn1.Type.SEQUENCE ||\r\n     authSafe.constructed !== true) {\r\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' +\r\n      'SEQUENCE OF ContentInfo');\r\n  }\r\n\r\n  for(var i = 0; i < authSafe.value.length; i++) {\r\n    var contentInfo = authSafe.value[i];\r\n\r\n    // validate contentInfo and capture data\r\n    var capture = {};\r\n    var errors = [];\r\n    if(!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\r\n      var error = new Error('Cannot read ContentInfo.');\r\n      error.errors = errors;\r\n      throw error;\r\n    }\r\n\r\n    var obj = {\r\n      encrypted: false\r\n    };\r\n    var safeContents = null;\r\n    var data = capture.content.value[0];\r\n    switch(asn1.derToOid(capture.contentType)) {\r\n    case pki.oids.data:\r\n      if(data.tagClass !== asn1.Class.UNIVERSAL ||\r\n         data.type !== asn1.Type.OCTETSTRING) {\r\n        throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\r\n      }\r\n      safeContents = _decodePkcs7Data(data).value;\r\n      break;\r\n    case pki.oids.encryptedData:\r\n      safeContents = _decryptSafeContents(data, password);\r\n      obj.encrypted = true;\r\n      break;\r\n    default:\r\n      var error = new Error('Unsupported PKCS#12 contentType.');\r\n      error.contentType = asn1.derToOid(capture.contentType);\r\n      throw error;\r\n    }\r\n\r\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\r\n    pfx.safeContents.push(obj);\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypt PKCS#7 EncryptedData structure.\r\n *\r\n * @param data ASN.1 encoded EncryptedContentInfo object.\r\n * @param password The user-provided password.\r\n *\r\n * @return The decrypted SafeContents (ASN.1 object).\r\n */\r\nfunction _decryptSafeContents(data, password) {\r\n  var capture = {};\r\n  var errors = [];\r\n  if(!asn1.validate(\r\n    data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\r\n    var error = new Error('Cannot read EncryptedContentInfo.');\r\n    error.errors = errors;\r\n    throw error;\r\n  }\r\n\r\n  var oid = asn1.derToOid(capture.contentType);\r\n  if(oid !== pki.oids.data) {\r\n    var error = new Error(\r\n      'PKCS#12 EncryptedContentInfo ContentType is not Data.');\r\n    error.oid = oid;\r\n    throw error;\r\n  }\r\n\r\n  // get cipher\r\n  oid = asn1.derToOid(capture.encAlgorithm);\r\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\r\n\r\n  // get encrypted data\r\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\r\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\r\n\r\n  cipher.update(encrypted);\r\n  if(!cipher.finish()) {\r\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\r\n  }\r\n\r\n  return cipher.output.getBytes();\r\n}\r\n\r\n/**\r\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\r\n *\r\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\r\n *\r\n * @param {String} safeContents BER-encoded safeContents.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return {Array} Array of Bag objects.\r\n */\r\nfunction _decodeSafeContents(safeContents, strict, password) {\r\n  // if strict and no safe contents, return empty safes\r\n  if(!strict && safeContents.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // actually it's BER-encoded\r\n  safeContents = asn1.fromDer(safeContents, strict);\r\n\r\n  if(safeContents.tagClass !== asn1.Class.UNIVERSAL ||\r\n    safeContents.type !== asn1.Type.SEQUENCE ||\r\n    safeContents.constructed !== true) {\r\n    throw new Error(\r\n      'PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\r\n  }\r\n\r\n  var res = [];\r\n  for(var i = 0; i < safeContents.value.length; i++) {\r\n    var safeBag = safeContents.value[i];\r\n\r\n    // validate SafeBag and capture data\r\n    var capture = {};\r\n    var errors = [];\r\n    if(!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\r\n      var error = new Error('Cannot read SafeBag.');\r\n      error.errors = errors;\r\n      throw error;\r\n    }\r\n\r\n    /* Create bag object and push to result array. */\r\n    var bag = {\r\n      type: asn1.derToOid(capture.bagId),\r\n      attributes: _decodeBagAttributes(capture.bagAttributes)\r\n    };\r\n    res.push(bag);\r\n\r\n    var validator, decoder;\r\n    var bagAsn1 = capture.bagValue.value[0];\r\n    switch(bag.type) {\r\n      case pki.oids.pkcs8ShroudedKeyBag:\r\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\r\n           Afterwards we can handle it like a keyBag,\r\n           which is a PrivateKeyInfo. */\r\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\r\n        if(bagAsn1 === null) {\r\n          throw new Error(\r\n            'Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\r\n        }\r\n\r\n        /* fall through */\r\n      case pki.oids.keyBag:\r\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\r\n           PKI module, hence we don't have to do validation/capturing here,\r\n           just pass what we already got. */\r\n        try {\r\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\r\n        } catch(e) {\r\n          // ignore unknown key type, pass asn1 value\r\n          bag.key = null;\r\n          bag.asn1 = bagAsn1;\r\n        }\r\n        continue;  /* Nothing more to do. */\r\n\r\n      case pki.oids.certBag:\r\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\r\n           Therefore put the SafeBag content through another validator to\r\n           capture the fields.  Afterwards check & store the results. */\r\n        validator = certBagValidator;\r\n        decoder = function() {\r\n          if(asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\r\n            var error = new Error(\r\n              'Unsupported certificate type, only X.509 supported.');\r\n            error.oid = asn1.derToOid(capture.certId);\r\n            throw error;\r\n          }\r\n\r\n          // true=produce cert hash\r\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\r\n          try {\r\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\r\n          } catch(e) {\r\n            // ignore unknown cert type, pass asn1 value\r\n            bag.cert = null;\r\n            bag.asn1 = certAsn1;\r\n          }\r\n        };\r\n        break;\r\n\r\n      default:\r\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\r\n        error.oid = bag.type;\r\n        throw error;\r\n    }\r\n\r\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\r\n    if(validator !== undefined &&\r\n       !asn1.validate(bagAsn1, validator, capture, errors)) {\r\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\r\n      error.errors = errors;\r\n      throw error;\r\n    }\r\n\r\n    /* Call decoder function from above to store the results. */\r\n    decoder();\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n/**\r\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\r\n *\r\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\r\n *\r\n * @return the decoded attributes.\r\n */\r\nfunction _decodeBagAttributes(attributes) {\r\n  var decodedAttrs = {};\r\n\r\n  if(attributes !== undefined) {\r\n    for(var i = 0; i < attributes.length; ++i) {\r\n      var capture = {};\r\n      var errors = [];\r\n      if(!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\r\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\r\n        error.errors = errors;\r\n        throw error;\r\n      }\r\n\r\n      var oid = asn1.derToOid(capture.oid);\r\n      if(pki.oids[oid] === undefined) {\r\n        // unsupported attribute type, ignore.\r\n        continue;\r\n      }\r\n\r\n      decodedAttrs[pki.oids[oid]] = [];\r\n      for(var j = 0; j < capture.values.length; ++j) {\r\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\r\n      }\r\n    }\r\n  }\r\n\r\n  return decodedAttrs;\r\n}\r\n\r\n/**\r\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\r\n * password is provided then the private key will be encrypted.\r\n *\r\n * An entire certificate chain may also be included. To do this, pass\r\n * an array for the \"cert\" parameter where the first certificate is\r\n * the one that is paired with the private key and each subsequent one\r\n * verifies the previous one. The certificates may be in PEM format or\r\n * have been already parsed by Forge.\r\n *\r\n * @todo implement password-based-encryption for the whole package\r\n *\r\n * @param key the private key.\r\n * @param cert the certificate (may be an array of certificates in order\r\n *          to specify a certificate chain).\r\n * @param password the password to use, null for none.\r\n * @param options:\r\n *          algorithm the encryption algorithm to use\r\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r\n *          count the iteration count to use.\r\n *          saltSize the salt size to use.\r\n *          useMac true to include a MAC, false not to, defaults to true.\r\n *          localKeyId the local key ID to use, in hex.\r\n *          friendlyName the friendly name to use.\r\n *          generateLocalKeyId true to generate a random local key ID,\r\n *            false not to, defaults to true.\r\n *\r\n * @return the PKCS#12 PFX ASN.1 object.\r\n */\r\np12.toPkcs12Asn1 = function(key, cert, password, options) {\r\n  // set default options\r\n  options = options || {};\r\n  options.saltSize = options.saltSize || 8;\r\n  options.count = options.count || 2048;\r\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\r\n  if(!('useMac' in options)) {\r\n    options.useMac = true;\r\n  }\r\n  if(!('localKeyId' in options)) {\r\n    options.localKeyId = null;\r\n  }\r\n  if(!('generateLocalKeyId' in options)) {\r\n    options.generateLocalKeyId = true;\r\n  }\r\n\r\n  var localKeyId = options.localKeyId;\r\n  var bagAttrs;\r\n  if(localKeyId !== null) {\r\n    localKeyId = forge.util.hexToBytes(localKeyId);\r\n  } else if(options.generateLocalKeyId) {\r\n    // use SHA-1 of paired cert, if available\r\n    if(cert) {\r\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\r\n      if(typeof pairedCert === 'string') {\r\n        pairedCert = pki.certificateFromPem(pairedCert);\r\n      }\r\n      var sha1 = forge.md.sha1.create();\r\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\r\n      localKeyId = sha1.digest().getBytes();\r\n    } else {\r\n      // FIXME: consider using SHA-1 of public key (which can be generated\r\n      // from private key components), see: cert.generateSubjectKeyIdentifier\r\n      // generate random bytes\r\n      localKeyId = forge.random.getBytes(20);\r\n    }\r\n  }\r\n\r\n  var attrs = [];\r\n  if(localKeyId !== null) {\r\n    attrs.push(\r\n      // localKeyID\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // attrId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.localKeyId).getBytes()),\r\n        // attrValues\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n            localKeyId)\r\n        ])\r\n      ]));\r\n  }\r\n  if('friendlyName' in options) {\r\n    attrs.push(\r\n      // friendlyName\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // attrId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.friendlyName).getBytes()),\r\n        // attrValues\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,\r\n            options.friendlyName)\r\n        ])\r\n      ]));\r\n  }\r\n\r\n  if(attrs.length > 0) {\r\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\r\n  }\r\n\r\n  // collect contents for AuthenticatedSafe\r\n  var contents = [];\r\n\r\n  // create safe bag(s) for certificate chain\r\n  var chain = [];\r\n  if(cert !== null) {\r\n    if(forge.util.isArray(cert)) {\r\n      chain = cert;\r\n    } else {\r\n      chain = [cert];\r\n    }\r\n  }\r\n\r\n  var certSafeBags = [];\r\n  for(var i = 0; i < chain.length; ++i) {\r\n    // convert cert from PEM as necessary\r\n    cert = chain[i];\r\n    if(typeof cert === 'string') {\r\n      cert = pki.certificateFromPem(cert);\r\n    }\r\n\r\n    // SafeBag\r\n    var certBagAttrs = (i === 0) ? bagAttrs : undefined;\r\n    var certAsn1 = pki.certificateToAsn1(cert);\r\n    var certSafeBag =\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // bagId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.certBag).getBytes()),\r\n        // bagValue\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          // CertBag\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n            // certId\r\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\r\n            // certValue (x509Certificate)\r\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n              asn1.create(\r\n                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n                asn1.toDer(certAsn1).getBytes())\r\n            ])])]),\r\n        // bagAttributes (OPTIONAL)\r\n        certBagAttrs\r\n      ]);\r\n    certSafeBags.push(certSafeBag);\r\n  }\r\n\r\n  if(certSafeBags.length > 0) {\r\n    // SafeContents\r\n    var certSafeContents = asn1.create(\r\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\r\n\r\n    // ContentInfo\r\n    var certCI =\r\n      // PKCS#7 ContentInfo\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // contentType\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          // OID for the content type is 'data'\r\n          asn1.oidToDer(pki.oids.data).getBytes()),\r\n        // content\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          asn1.create(\r\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n            asn1.toDer(certSafeContents).getBytes())\r\n        ])\r\n      ]);\r\n    contents.push(certCI);\r\n  }\r\n\r\n  // create safe contents for private key\r\n  var keyBag = null;\r\n  if(key !== null) {\r\n    // SafeBag\r\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\r\n    if(password === null) {\r\n      // no encryption\r\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // bagId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.keyBag).getBytes()),\r\n        // bagValue\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          // PrivateKeyInfo\r\n          pkAsn1\r\n        ]),\r\n        // bagAttributes (OPTIONAL)\r\n        bagAttrs\r\n      ]);\r\n    } else {\r\n      // encrypted PrivateKeyInfo\r\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // bagId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\r\n        // bagValue\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          // EncryptedPrivateKeyInfo\r\n          pki.encryptPrivateKeyInfo(pkAsn1, password, options)\r\n        ]),\r\n        // bagAttributes (OPTIONAL)\r\n        bagAttrs\r\n      ]);\r\n    }\r\n\r\n    // SafeContents\r\n    var keySafeContents =\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\r\n\r\n    // ContentInfo\r\n    var keyCI =\r\n      // PKCS#7 ContentInfo\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // contentType\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          // OID for the content type is 'data'\r\n          asn1.oidToDer(pki.oids.data).getBytes()),\r\n        // content\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          asn1.create(\r\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n            asn1.toDer(keySafeContents).getBytes())\r\n        ])\r\n      ]);\r\n    contents.push(keyCI);\r\n  }\r\n\r\n  // create AuthenticatedSafe by stringing together the contents\r\n  var safe = asn1.create(\r\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\r\n\r\n  var macData;\r\n  if(options.useMac) {\r\n    // MacData\r\n    var sha1 = forge.md.sha1.create();\r\n    var macSalt = new forge.util.ByteBuffer(\r\n      forge.random.getBytes(options.saltSize));\r\n    var count = options.count;\r\n    // 160-bit key\r\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\r\n    var mac = forge.hmac.create();\r\n    mac.start(sha1, key);\r\n    mac.update(asn1.toDer(safe).getBytes());\r\n    var macValue = mac.getMac();\r\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n      // mac DigestInfo\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // digestAlgorithm\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n          // algorithm = SHA-1\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n            asn1.oidToDer(pki.oids.sha1).getBytes()),\r\n          // parameters = Null\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r\n        ]),\r\n        // digest\r\n        asn1.create(\r\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\r\n          false, macValue.getBytes())\r\n      ]),\r\n      // macSalt OCTET STRING\r\n      asn1.create(\r\n        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\r\n      // iterations INTEGER (XXX: Only support count < 65536)\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r\n        asn1.integerToDer(count).getBytes()\r\n      )\r\n    ]);\r\n  }\r\n\r\n  // PFX\r\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n    // version (3)\r\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r\n      asn1.integerToDer(3).getBytes()),\r\n    // PKCS#7 ContentInfo\r\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n      // contentType\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n        // OID for the content type is 'data'\r\n        asn1.oidToDer(pki.oids.data).getBytes()),\r\n      // content\r\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n        asn1.create(\r\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n          asn1.toDer(safe).getBytes())\r\n      ])\r\n    ]),\r\n    macData\r\n  ]);\r\n};\r\n\r\n/**\r\n * Derives a PKCS#12 key.\r\n *\r\n * @param password the password to derive the key material from, null or\r\n *          undefined for none.\r\n * @param salt the salt, as a ByteBuffer, to use.\r\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r\n * @param iter the iteration count.\r\n * @param n the number of bytes to derive from the password.\r\n * @param md the message digest to use, defaults to SHA-1.\r\n *\r\n * @return a ByteBuffer with the bytes derived from the password.\r\n */\r\np12.generateKey = forge.pbe.generatePkcs12Key;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC9BA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,aAAa,CAAC;AACtBA,OAAO,CAAC,OAAO,CAAC;AAChBA,OAAO,CAAC,UAAU,CAAC;AACnBA,OAAO,CAAC,OAAO,CAAC;AAChBA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,QAAQ,CAAC;AACjBA,OAAO,CAAC,QAAQ,CAAC;;AAEjB;AACA,IAAIC,IAAI,GAAGF,KAAK,CAACE,IAAI;AACrB,IAAIC,GAAG,GAAGH,KAAK,CAACG,GAAG;;AAEnB;AACA,IAAIC,GAAG,GAAGC,MAAM,CAACC,OAAO,GAAGN,KAAK,CAACO,MAAM,GAAGP,KAAK,CAACO,MAAM,IAAI,CAAC,CAAC;AAE5D,IAAIC,oBAAoB,GAAG;EACzBC,IAAI,EAAE,aAAa;EACnBC,QAAQ,EAAER,IAAI,CAACS,KAAK,CAACC,SAAS;EAC9BC,IAAI,EAAEX,IAAI,CAACY,IAAI,CAACC,QAAQ;EAAG;EAC3BC,WAAW,EAAE,IAAI;EACjBC,KAAK,EAAE,CAAC;IACNR,IAAI,EAAE,yBAAyB;IAC/BC,QAAQ,EAAER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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}