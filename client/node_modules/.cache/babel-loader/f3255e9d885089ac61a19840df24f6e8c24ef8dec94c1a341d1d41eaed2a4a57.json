{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.primitiveComparator = primitiveComparator;\nexports.compareArrays = compareArrays;\nexports.compareUtf8Strings = compareUtf8Strings;\nexports.compare = compare;\nconst convert_1 = require(\"./convert\");\nconst path_1 = require(\"./path\");\n/*!\n * The type order as defined by the backend.\n */\nvar TypeOrder;\n(function (TypeOrder) {\n  TypeOrder[TypeOrder[\"NULL\"] = 0] = \"NULL\";\n  TypeOrder[TypeOrder[\"BOOLEAN\"] = 1] = \"BOOLEAN\";\n  TypeOrder[TypeOrder[\"NUMBER\"] = 2] = \"NUMBER\";\n  TypeOrder[TypeOrder[\"TIMESTAMP\"] = 3] = \"TIMESTAMP\";\n  TypeOrder[TypeOrder[\"STRING\"] = 4] = \"STRING\";\n  TypeOrder[TypeOrder[\"BLOB\"] = 5] = \"BLOB\";\n  TypeOrder[TypeOrder[\"REF\"] = 6] = \"REF\";\n  TypeOrder[TypeOrder[\"GEO_POINT\"] = 7] = \"GEO_POINT\";\n  TypeOrder[TypeOrder[\"ARRAY\"] = 8] = \"ARRAY\";\n  TypeOrder[TypeOrder[\"VECTOR\"] = 9] = \"VECTOR\";\n  TypeOrder[TypeOrder[\"OBJECT\"] = 10] = \"OBJECT\";\n})(TypeOrder || (TypeOrder = {}));\n/*!\n * @private\n * @internal\n */\nfunction typeOrder(val) {\n  const valueType = (0, convert_1.detectValueType)(val);\n  switch (valueType) {\n    case 'nullValue':\n      return TypeOrder.NULL;\n    case 'integerValue':\n      return TypeOrder.NUMBER;\n    case 'doubleValue':\n      return TypeOrder.NUMBER;\n    case 'stringValue':\n      return TypeOrder.STRING;\n    case 'booleanValue':\n      return TypeOrder.BOOLEAN;\n    case 'arrayValue':\n      return TypeOrder.ARRAY;\n    case 'timestampValue':\n      return TypeOrder.TIMESTAMP;\n    case 'geoPointValue':\n      return TypeOrder.GEO_POINT;\n    case 'bytesValue':\n      return TypeOrder.BLOB;\n    case 'referenceValue':\n      return TypeOrder.REF;\n    case 'mapValue':\n      return TypeOrder.OBJECT;\n    case 'vectorValue':\n      return TypeOrder.VECTOR;\n    default:\n      throw new Error('Unexpected value type: ' + valueType);\n  }\n}\n/*!\n * @private\n * @internal\n */\nfunction primitiveComparator(left, right) {\n  if (left < right) {\n    return -1;\n  }\n  if (left > right) {\n    return 1;\n  }\n  return 0;\n}\n/*!\n * Utility function to compare doubles (using Firestore semantics for NaN).\n * @private\n * @internal\n */\nfunction compareNumbers(left, right) {\n  if (left < right) {\n    return -1;\n  }\n  if (left > right) {\n    return 1;\n  }\n  if (left === right) {\n    return 0;\n  }\n  // one or both are NaN.\n  if (isNaN(left)) {\n    return isNaN(right) ? 0 : -1;\n  }\n  return 1;\n}\n/*!\n * @private\n * @internal\n */\nfunction compareNumberProtos(left, right) {\n  let leftValue, rightValue;\n  if (left.integerValue !== undefined) {\n    leftValue = Number(left.integerValue);\n  } else {\n    leftValue = Number(left.doubleValue);\n  }\n  if (right.integerValue !== undefined) {\n    rightValue = Number(right.integerValue);\n  } else {\n    rightValue = Number(right.doubleValue);\n  }\n  return compareNumbers(leftValue, rightValue);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareTimestamps(left, right) {\n  const seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);\n  if (seconds !== 0) {\n    return seconds;\n  }\n  return primitiveComparator(left.nanos || 0, right.nanos || 0);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareBlobs(left, right) {\n  if (!(left instanceof Buffer) || !(right instanceof Buffer)) {\n    throw new Error('Blobs can only be compared if they are Buffers.');\n  }\n  return Buffer.compare(left, right);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareReferenceProtos(left, right) {\n  const leftPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(left.referenceValue);\n  const rightPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(right.referenceValue);\n  return leftPath.compareTo(rightPath);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareGeoPoints(left, right) {\n  return primitiveComparator(left.latitude || 0, right.latitude || 0) || primitiveComparator(left.longitude || 0, right.longitude || 0);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareArrays(left, right) {\n  for (let i = 0; i < left.length && i < right.length; i++) {\n    const valueComparison = compare(left[i], right[i]);\n    if (valueComparison !== 0) {\n      return valueComparison;\n    }\n  }\n  // If all the values matched so far, just check the length.\n  return primitiveComparator(left.length, right.length);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareObjects(left, right) {\n  // This requires iterating over the keys in the object in order and doing a\n  // deep comparison.\n  const leftKeys = Object.keys(left);\n  const rightKeys = Object.keys(right);\n  leftKeys.sort();\n  rightKeys.sort();\n  for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n    const keyComparison = compareUtf8Strings(leftKeys[i], rightKeys[i]);\n    if (keyComparison !== 0) {\n      return keyComparison;\n    }\n    const key = leftKeys[i];\n    const valueComparison = compare(left[key], right[key]);\n    if (valueComparison !== 0) {\n      return valueComparison;\n    }\n  }\n  // If all the keys matched so far, just check the length.\n  return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareVectors(left, right) {\n  var _a, _b, _c, _d, _e, _f;\n  // The vector is a map, but only vector value is compared.\n  const leftArray = (_c = (_b = (_a = left === null || left === void 0 ? void 0 : left['value']) === null || _a === void 0 ? void 0 : _a.arrayValue) === null || _b === void 0 ? void 0 : _b.values) !== null && _c !== void 0 ? _c : [];\n  const rightArray = (_f = (_e = (_d = right === null || right === void 0 ? void 0 : right['value']) === null || _d === void 0 ? void 0 : _d.arrayValue) === null || _e === void 0 ? void 0 : _e.values) !== null && _f !== void 0 ? _f : [];\n  const lengthCompare = primitiveComparator(leftArray.length, rightArray.length);\n  if (lengthCompare !== 0) {\n    return lengthCompare;\n  }\n  return compareArrays(leftArray, rightArray);\n}\n/*!\n * Compare strings in UTF-8 encoded byte order\n * @private\n * @internal\n */\nfunction compareUtf8Strings(left, right) {\n  // Find the first differing character (a.k.a. \"UTF-16 code unit\") in the two strings and,\n  // if found, use that character to determine the relative ordering of the two strings as a\n  // whole. Comparing UTF-16 strings in UTF-8 byte order can be done simply and efficiently by\n  // comparing the UTF-16 code units (chars). This serendipitously works because of the way UTF-8\n  // and UTF-16 happen to represent Unicode code points.\n  //\n  // After finding the first pair of differing characters, there are two cases:\n  //\n  // Case 1: Both characters are non-surrogates (code points less than or equal to 0xFFFF) or\n  // both are surrogates from a surrogate pair (that collectively represent code points greater\n  // than 0xFFFF). In this case their numeric order as UTF-16 code units is the same as the\n  // lexicographical order of their corresponding UTF-8 byte sequences. A direct comparison is\n  // sufficient.\n  //\n  // Case 2: One character is a surrogate and the other is not. In this case the surrogate-\n  // containing string is always ordered after the non-surrogate. This is because surrogates are\n  // used to represent code points greater than 0xFFFF which have 4-byte UTF-8 representations\n  // and are lexicographically greater than the 1, 2, or 3-byte representations of code points\n  // less than or equal to 0xFFFF.\n  //\n  // An example of why Case 2 is required is comparing the following two Unicode code points:\n  //\n  // |-----------------------|------------|---------------------|-----------------|\n  // | Name                  | Code Point | UTF-8 Encoding      | UTF-16 Encoding |\n  // |-----------------------|------------|---------------------|-----------------|\n  // | Replacement Character | U+FFFD     | 0xEF 0xBF 0xBD      | 0xFFFD          |\n  // | Grinning Face         | U+1F600    | 0xF0 0x9F 0x98 0x80 | 0xD83D 0xDE00   |\n  // |-----------------------|------------|---------------------|-----------------|\n  //\n  // A lexicographical comparison of the UTF-8 encodings of these code points would order\n  // \"Replacement Character\" _before_ \"Grinning Face\" because 0xEF is less than 0xF0. However, a\n  // direct comparison of the UTF-16 code units, as would be done in case 1, would erroneously\n  // produce the _opposite_ ordering, because 0xFFFD is _greater than_ 0xD83D. As it turns out,\n  // this relative ordering holds for all comparisons of UTF-16 code points requiring a surrogate\n  // pair with those that do not.\n  const length = Math.min(left.length, right.length);\n  for (let i = 0; i < length; i++) {\n    const leftChar = left.charAt(i);\n    const rightChar = right.charAt(i);\n    if (leftChar !== rightChar) {\n      return isSurrogate(leftChar) === isSurrogate(rightChar) ? primitiveComparator(leftChar, rightChar) : isSurrogate(leftChar) ? 1 : -1;\n    }\n  }\n  // Use the lengths of the strings to determine the overall comparison result since either the\n  // strings were equal or one is a prefix of the other.\n  return primitiveComparator(left.length, right.length);\n}\nconst MIN_SURROGATE = 0xd800;\nconst MAX_SURROGATE = 0xdfff;\nfunction isSurrogate(s) {\n  const c = s.charCodeAt(0);\n  return c >= MIN_SURROGATE && c <= MAX_SURROGATE;\n}\n/*!\n * @private\n * @internal\n */\nfunction compare(left, right) {\n  // First compare the types.\n  const leftType = typeOrder(left);\n  const rightType = typeOrder(right);\n  const typeComparison = primitiveComparator(leftType, rightType);\n  if (typeComparison !== 0) {\n    return typeComparison;\n  }\n  // So they are the same type.\n  switch (leftType) {\n    case TypeOrder.NULL:\n      // Nulls are all equal.\n      return 0;\n    case TypeOrder.BOOLEAN:\n      return primitiveComparator(left.booleanValue, right.booleanValue);\n    case TypeOrder.STRING:\n      return compareUtf8Strings(left.stringValue, right.stringValue);\n    case TypeOrder.NUMBER:\n      return compareNumberProtos(left, right);\n    case TypeOrder.TIMESTAMP:\n      return compareTimestamps(left.timestampValue, right.timestampValue);\n    case TypeOrder.BLOB:\n      return compareBlobs(left.bytesValue, right.bytesValue);\n    case TypeOrder.REF:\n      return compareReferenceProtos(left, right);\n    case TypeOrder.GEO_POINT:\n      return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n    case TypeOrder.ARRAY:\n      return compareArrays(left.arrayValue.values || [], right.arrayValue.values || []);\n    case TypeOrder.OBJECT:\n      return compareObjects(left.mapValue.fields || {}, right.mapValue.fields || {});\n    case TypeOrder.VECTOR:\n      return compareVectors(left.mapValue.fields || {}, right.mapValue.fields || {});\n    default:\n      throw new Error(`Encountered unknown type order: ${leftType}`);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","primitiveComparator","compareArrays","compareUtf8Strings","compare","convert_1","require","path_1","TypeOrder","typeOrder","val","valueType","detectValueType","NULL","NUMBER","STRING","BOOLEAN","ARRAY","TIMESTAMP","GEO_POINT","BLOB","REF","OBJECT","VECTOR","Error","left","right","compareNumbers","isNaN","compareNumberProtos","leftValue","rightValue","integerValue","undefined","Number","doubleValue","compareTimestamps","seconds","nanos","compareBlobs","Buffer","compareReferenceProtos","leftPath","QualifiedResourcePath","fromSlashSeparatedString","referenceValue","rightPath","compareTo","compareGeoPoints","latitude","longitude","i","length","valueComparison","compareObjects","leftKeys","keys","rightKeys","sort","keyComparison","key","compareVectors","_a","_b","_c","_d","_e","_f","leftArray","arrayValue","values","rightArray","lengthCompare","Math","min","leftChar","charAt","rightChar","isSurrogate","MIN_SURROGATE","MAX_SURROGATE","s","c","charCodeAt","leftType","rightType","typeComparison","booleanValue","stringValue","timestampValue","bytesValue","geoPointValue","mapValue","fields"],"sources":["C:/Users/PROGRAMMER/Desktop/goal tracker app clone/goal-tracker-app/client/node_modules/@google-cloud/firestore/build/src/order.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.primitiveComparator = primitiveComparator;\nexports.compareArrays = compareArrays;\nexports.compareUtf8Strings = compareUtf8Strings;\nexports.compare = compare;\nconst convert_1 = require(\"./convert\");\nconst path_1 = require(\"./path\");\n/*!\n * The type order as defined by the backend.\n */\nvar TypeOrder;\n(function (TypeOrder) {\n    TypeOrder[TypeOrder[\"NULL\"] = 0] = \"NULL\";\n    TypeOrder[TypeOrder[\"BOOLEAN\"] = 1] = \"BOOLEAN\";\n    TypeOrder[TypeOrder[\"NUMBER\"] = 2] = \"NUMBER\";\n    TypeOrder[TypeOrder[\"TIMESTAMP\"] = 3] = \"TIMESTAMP\";\n    TypeOrder[TypeOrder[\"STRING\"] = 4] = \"STRING\";\n    TypeOrder[TypeOrder[\"BLOB\"] = 5] = \"BLOB\";\n    TypeOrder[TypeOrder[\"REF\"] = 6] = \"REF\";\n    TypeOrder[TypeOrder[\"GEO_POINT\"] = 7] = \"GEO_POINT\";\n    TypeOrder[TypeOrder[\"ARRAY\"] = 8] = \"ARRAY\";\n    TypeOrder[TypeOrder[\"VECTOR\"] = 9] = \"VECTOR\";\n    TypeOrder[TypeOrder[\"OBJECT\"] = 10] = \"OBJECT\";\n})(TypeOrder || (TypeOrder = {}));\n/*!\n * @private\n * @internal\n */\nfunction typeOrder(val) {\n    const valueType = (0, convert_1.detectValueType)(val);\n    switch (valueType) {\n        case 'nullValue':\n            return TypeOrder.NULL;\n        case 'integerValue':\n            return TypeOrder.NUMBER;\n        case 'doubleValue':\n            return TypeOrder.NUMBER;\n        case 'stringValue':\n            return TypeOrder.STRING;\n        case 'booleanValue':\n            return TypeOrder.BOOLEAN;\n        case 'arrayValue':\n            return TypeOrder.ARRAY;\n        case 'timestampValue':\n            return TypeOrder.TIMESTAMP;\n        case 'geoPointValue':\n            return TypeOrder.GEO_POINT;\n        case 'bytesValue':\n            return TypeOrder.BLOB;\n        case 'referenceValue':\n            return TypeOrder.REF;\n        case 'mapValue':\n            return TypeOrder.OBJECT;\n        case 'vectorValue':\n            return TypeOrder.VECTOR;\n        default:\n            throw new Error('Unexpected value type: ' + valueType);\n    }\n}\n/*!\n * @private\n * @internal\n */\nfunction primitiveComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    return 0;\n}\n/*!\n * Utility function to compare doubles (using Firestore semantics for NaN).\n * @private\n * @internal\n */\nfunction compareNumbers(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    if (left === right) {\n        return 0;\n    }\n    // one or both are NaN.\n    if (isNaN(left)) {\n        return isNaN(right) ? 0 : -1;\n    }\n    return 1;\n}\n/*!\n * @private\n * @internal\n */\nfunction compareNumberProtos(left, right) {\n    let leftValue, rightValue;\n    if (left.integerValue !== undefined) {\n        leftValue = Number(left.integerValue);\n    }\n    else {\n        leftValue = Number(left.doubleValue);\n    }\n    if (right.integerValue !== undefined) {\n        rightValue = Number(right.integerValue);\n    }\n    else {\n        rightValue = Number(right.doubleValue);\n    }\n    return compareNumbers(leftValue, rightValue);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareTimestamps(left, right) {\n    const seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);\n    if (seconds !== 0) {\n        return seconds;\n    }\n    return primitiveComparator(left.nanos || 0, right.nanos || 0);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareBlobs(left, right) {\n    if (!(left instanceof Buffer) || !(right instanceof Buffer)) {\n        throw new Error('Blobs can only be compared if they are Buffers.');\n    }\n    return Buffer.compare(left, right);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareReferenceProtos(left, right) {\n    const leftPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(left.referenceValue);\n    const rightPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(right.referenceValue);\n    return leftPath.compareTo(rightPath);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareGeoPoints(left, right) {\n    return (primitiveComparator(left.latitude || 0, right.latitude || 0) ||\n        primitiveComparator(left.longitude || 0, right.longitude || 0));\n}\n/*!\n * @private\n * @internal\n */\nfunction compareArrays(left, right) {\n    for (let i = 0; i < left.length && i < right.length; i++) {\n        const valueComparison = compare(left[i], right[i]);\n        if (valueComparison !== 0) {\n            return valueComparison;\n        }\n    }\n    // If all the values matched so far, just check the length.\n    return primitiveComparator(left.length, right.length);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareObjects(left, right) {\n    // This requires iterating over the keys in the object in order and doing a\n    // deep comparison.\n    const leftKeys = Object.keys(left);\n    const rightKeys = Object.keys(right);\n    leftKeys.sort();\n    rightKeys.sort();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n        const keyComparison = compareUtf8Strings(leftKeys[i], rightKeys[i]);\n        if (keyComparison !== 0) {\n            return keyComparison;\n        }\n        const key = leftKeys[i];\n        const valueComparison = compare(left[key], right[key]);\n        if (valueComparison !== 0) {\n            return valueComparison;\n        }\n    }\n    // If all the keys matched so far, just check the length.\n    return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/*!\n * @private\n * @internal\n */\nfunction compareVectors(left, right) {\n    var _a, _b, _c, _d, _e, _f;\n    // The vector is a map, but only vector value is compared.\n    const leftArray = (_c = (_b = (_a = left === null || left === void 0 ? void 0 : left['value']) === null || _a === void 0 ? void 0 : _a.arrayValue) === null || _b === void 0 ? void 0 : _b.values) !== null && _c !== void 0 ? _c : [];\n    const rightArray = (_f = (_e = (_d = right === null || right === void 0 ? void 0 : right['value']) === null || _d === void 0 ? void 0 : _d.arrayValue) === null || _e === void 0 ? void 0 : _e.values) !== null && _f !== void 0 ? _f : [];\n    const lengthCompare = primitiveComparator(leftArray.length, rightArray.length);\n    if (lengthCompare !== 0) {\n        return lengthCompare;\n    }\n    return compareArrays(leftArray, rightArray);\n}\n/*!\n * Compare strings in UTF-8 encoded byte order\n * @private\n * @internal\n */\nfunction compareUtf8Strings(left, right) {\n    // Find the first differing character (a.k.a. \"UTF-16 code unit\") in the two strings and,\n    // if found, use that character to determine the relative ordering of the two strings as a\n    // whole. Comparing UTF-16 strings in UTF-8 byte order can be done simply and efficiently by\n    // comparing the UTF-16 code units (chars). This serendipitously works because of the way UTF-8\n    // and UTF-16 happen to represent Unicode code points.\n    //\n    // After finding the first pair of differing characters, there are two cases:\n    //\n    // Case 1: Both characters are non-surrogates (code points less than or equal to 0xFFFF) or\n    // both are surrogates from a surrogate pair (that collectively represent code points greater\n    // than 0xFFFF). In this case their numeric order as UTF-16 code units is the same as the\n    // lexicographical order of their corresponding UTF-8 byte sequences. A direct comparison is\n    // sufficient.\n    //\n    // Case 2: One character is a surrogate and the other is not. In this case the surrogate-\n    // containing string is always ordered after the non-surrogate. This is because surrogates are\n    // used to represent code points greater than 0xFFFF which have 4-byte UTF-8 representations\n    // and are lexicographically greater than the 1, 2, or 3-byte representations of code points\n    // less than or equal to 0xFFFF.\n    //\n    // An example of why Case 2 is required is comparing the following two Unicode code points:\n    //\n    // |-----------------------|------------|---------------------|-----------------|\n    // | Name                  | Code Point | UTF-8 Encoding      | UTF-16 Encoding |\n    // |-----------------------|------------|---------------------|-----------------|\n    // | Replacement Character | U+FFFD     | 0xEF 0xBF 0xBD      | 0xFFFD          |\n    // | Grinning Face         | U+1F600    | 0xF0 0x9F 0x98 0x80 | 0xD83D 0xDE00   |\n    // |-----------------------|------------|---------------------|-----------------|\n    //\n    // A lexicographical comparison of the UTF-8 encodings of these code points would order\n    // \"Replacement Character\" _before_ \"Grinning Face\" because 0xEF is less than 0xF0. However, a\n    // direct comparison of the UTF-16 code units, as would be done in case 1, would erroneously\n    // produce the _opposite_ ordering, because 0xFFFD is _greater than_ 0xD83D. As it turns out,\n    // this relative ordering holds for all comparisons of UTF-16 code points requiring a surrogate\n    // pair with those that do not.\n    const length = Math.min(left.length, right.length);\n    for (let i = 0; i < length; i++) {\n        const leftChar = left.charAt(i);\n        const rightChar = right.charAt(i);\n        if (leftChar !== rightChar) {\n            return isSurrogate(leftChar) === isSurrogate(rightChar)\n                ? primitiveComparator(leftChar, rightChar)\n                : isSurrogate(leftChar)\n                    ? 1\n                    : -1;\n        }\n    }\n    // Use the lengths of the strings to determine the overall comparison result since either the\n    // strings were equal or one is a prefix of the other.\n    return primitiveComparator(left.length, right.length);\n}\nconst MIN_SURROGATE = 0xd800;\nconst MAX_SURROGATE = 0xdfff;\nfunction isSurrogate(s) {\n    const c = s.charCodeAt(0);\n    return c >= MIN_SURROGATE && c <= MAX_SURROGATE;\n}\n/*!\n * @private\n * @internal\n */\nfunction compare(left, right) {\n    // First compare the types.\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    const typeComparison = primitiveComparator(leftType, rightType);\n    if (typeComparison !== 0) {\n        return typeComparison;\n    }\n    // So they are the same type.\n    switch (leftType) {\n        case TypeOrder.NULL:\n            // Nulls are all equal.\n            return 0;\n        case TypeOrder.BOOLEAN:\n            return primitiveComparator(left.booleanValue, right.booleanValue);\n        case TypeOrder.STRING:\n            return compareUtf8Strings(left.stringValue, right.stringValue);\n        case TypeOrder.NUMBER:\n            return compareNumberProtos(left, right);\n        case TypeOrder.TIMESTAMP:\n            return compareTimestamps(left.timestampValue, right.timestampValue);\n        case TypeOrder.BLOB:\n            return compareBlobs(left.bytesValue, right.bytesValue);\n        case TypeOrder.REF:\n            return compareReferenceProtos(left, right);\n        case TypeOrder.GEO_POINT:\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n        case TypeOrder.ARRAY:\n            return compareArrays(left.arrayValue.values || [], right.arrayValue.values || []);\n        case TypeOrder.OBJECT:\n            return compareObjects(left.mapValue.fields || {}, right.mapValue.fields || {});\n        case TypeOrder.VECTOR:\n            return compareVectors(left.mapValue.fields || {}, right.mapValue.fields || {});\n        default:\n            throw new Error(`Encountered unknown type order: ${leftType}`);\n    }\n}\n//# sourceMappingURL=order.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}