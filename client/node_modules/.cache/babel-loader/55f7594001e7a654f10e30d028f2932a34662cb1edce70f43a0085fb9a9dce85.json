{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamProxy = exports.StreamType = void 0;\nconst gax_1 = require(\"../gax\");\nconst googleError_1 = require(\"../googleError\");\nconst status_1 = require(\"../status\");\nconst stream_1 = require(\"stream\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst retryRequest = require('retry-request');\n/**\n * The type of gRPC streaming.\n * @enum {number}\n */\nvar StreamType;\n(function (StreamType) {\n  /** Client sends a single request, server streams responses. */\n  StreamType[StreamType[\"SERVER_STREAMING\"] = 1] = \"SERVER_STREAMING\";\n  /** Client streams requests, server returns a single response. */\n  StreamType[StreamType[\"CLIENT_STREAMING\"] = 2] = \"CLIENT_STREAMING\";\n  /** Both client and server stream objects. */\n  StreamType[StreamType[\"BIDI_STREAMING\"] = 3] = \"BIDI_STREAMING\";\n})(StreamType || (exports.StreamType = StreamType = {}));\n// In retry-request, you could pass parameters to request using the requestOpts parameter\n// when we called retry-request from gax, we always passed null\n// passing null here removes an unnecessary parameter from this implementation\nconst requestOps = null;\nclass StreamProxy extends duplexify {\n  /**\n   * StreamProxy is a proxy to gRPC-streaming method.\n   *\n   * @private\n   * @constructor\n   * @param {StreamType} type - the type of gRPC stream.\n   * @param {ApiCallback} callback - the callback for further API call.\n   */\n  constructor(type, callback, rest, gaxServerStreamingRetries) {\n    super(undefined, undefined, {\n      objectMode: true,\n      readable: type !== StreamType.CLIENT_STREAMING,\n      writable: type !== StreamType.SERVER_STREAMING\n    });\n    this.type = type;\n    this._callback = callback;\n    this._isCancelCalled = false;\n    this._responseHasSent = false;\n    this.rest = rest;\n    this.gaxServerStreamingRetries = gaxServerStreamingRetries;\n  }\n  shouldRetryRequest(error, retry) {\n    const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n    let shouldRetry = this.defaultShouldRetry(e, retry);\n    if (retry.shouldRetryFn) {\n      shouldRetry = retry.shouldRetryFn(e);\n    }\n    return shouldRetry;\n  }\n  cancel() {\n    if (this.stream) {\n      this.stream.cancel();\n    } else {\n      this._isCancelCalled = true;\n    }\n  }\n  /**\n   * Helper function to handle total timeout + max retry check for server streaming retries\n   * @param {number} deadline - the current retry deadline\n   * @param {number} maxRetries - maximum total number of retries\n   * @param {number} totalTimeoutMillis - total timeout in milliseconds used in timeout calculation\n   * @param {GoogleError} originalError - underlying error received by the stream\n   * @param {originalTimeout} originalTimeout - the original Timeout set in backoff settings\n   * @param {retries} retries - the number of retries the call has made so far\n   */\n  throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, totalTimeoutMillis, originalError, originalTimeout, retries) {\n    const now = new Date();\n    const nowTime = now.getTime();\n    if (originalTimeout && (totalTimeoutMillis === 0 || totalTimeoutMillis < 0 || deadline && nowTime >= deadline)) {\n      const error = new googleError_1.GoogleError(`Total timeout of API exceeded ${originalTimeout} milliseconds ${originalError ? `retrying error ${originalError} ` : ''} before any response was received.`);\n      error.code = status_1.Status.DEADLINE_EXCEEDED;\n      throw error;\n    }\n    if (maxRetries === 0) {\n      const error = originalError;\n      error.note = 'Max retries is set to zero.';\n      throw error;\n    }\n    if (retries && retries >= maxRetries) {\n      const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' + (originalError ? `retrying error ${originalError} ` : '') + 'before any response was received');\n      error.code = status_1.Status.DEADLINE_EXCEEDED;\n      throw error;\n    }\n  }\n  /**\n   * Forwards events from an API request stream to the user's stream.\n   * @param {Stream} stream - The API request stream.\n   */\n  eventForwardHelper(stream) {\n    const eventsToForward = ['metadata', 'response', 'status'];\n    eventsToForward.forEach(event => {\n      stream.on(event, this.emit.bind(this, event));\n    });\n  }\n  /**\n   * Helper function that emits a response on the stream after either a 'metadata'\n   * or a 'status' event - this helps streams to behave more like http consumers expect\n   * @param {Stream} stream - The API request stream.\n   */\n  statusMetadataHelper(stream) {\n    // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n    // Emit the 'response' event if stream has no 'metadata' event.\n    // This avoids the stream swallowing the other events, such as 'end'.\n    stream.on('status', () => {\n      if (!this._responseHasSent) {\n        stream.emit('response', {\n          code: 200,\n          details: '',\n          message: 'OK'\n        });\n      }\n    });\n    // We also want to supply the status data as 'response' event to support\n    // the behavior of google-cloud-node expects.\n    // see:\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n    stream.on('metadata', metadata => {\n      // Create a response object with succeeds.\n      // TODO: unify this logic with the decoration of gRPC response when it's\n      // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n      stream.emit('response', {\n        code: 200,\n        details: '',\n        message: 'OK',\n        metadata\n      });\n      this._responseHasSent = true;\n    });\n  }\n  /**\n   * Forward events from an API request stream to the user's stream.\n   * @param {Stream} stream - The API request stream.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  forwardEvents(stream) {\n    this.eventForwardHelper(stream);\n    this.statusMetadataHelper(stream);\n    stream.on('error', error => {\n      googleError_1.GoogleError.parseGRPCStatusDetails(error);\n    });\n  }\n  /**\n   * Default mechanism for determining whether a streaming call should retry\n   * If a user passes in a \"shouldRetryFn\", this will not be used\n   * @param {GoogleError} errpr - The error we need to determine is retryable or not\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  defaultShouldRetry(error, retry) {\n    if (retry.retryCodes.length > 0 && retry.retryCodes.indexOf(error.code) < 0 || retry.retryCodes.length === 0) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Specifies the target stream.\n   * @param {ApiCall} apiCall - the API function to be called.\n   * @param {Object} argument - the argument to be passed to the apiCall.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  setStream(apiCall, argument, retryRequestOptions = {}, retry) {\n    this.apiCall = apiCall;\n    this.argument = argument;\n    if (this.type === StreamType.SERVER_STREAMING) {\n      if (this.rest) {\n        const stream = apiCall(argument, this._callback);\n        this.stream = stream;\n        this.setReadable(stream);\n      } else if (this.gaxServerStreamingRetries) {\n        const request = () => {\n          if (this._isCancelCalled) {\n            if (this.stream) {\n              this.stream.cancel();\n            }\n            return;\n          }\n          const stream = apiCall(argument, this._callback);\n          return stream;\n        };\n        const retryStream = this.newStreamingRetryRequest({\n          request,\n          retry\n        });\n        this.stream = retryStream;\n        this.eventForwardHelper(retryStream);\n        this.setReadable(retryStream);\n      } else {\n        const retryStream = retryRequest(null, {\n          objectMode: true,\n          request: () => {\n            if (this._isCancelCalled) {\n              if (this.stream) {\n                this.stream.cancel();\n              }\n              return;\n            }\n            const stream = apiCall(argument, this._callback);\n            this.stream = stream;\n            this.forwardEvents(stream);\n            return stream;\n          },\n          retries: retryRequestOptions.retries,\n          currentRetryAttempt: retryRequestOptions.currentRetryAttempt,\n          noResponseRetries: retryRequestOptions.noResponseRetries,\n          shouldRetryFn: retryRequestOptions.shouldRetryFn\n        });\n        this.setReadable(retryStream);\n      }\n      return;\n    }\n    const stream = apiCall(argument, this._callback);\n    this.stream = stream;\n    this.forwardEvents(stream);\n    if (this.type === StreamType.CLIENT_STREAMING) {\n      this.setWritable(stream);\n    }\n    if (this.type === StreamType.BIDI_STREAMING) {\n      this.setReadable(stream);\n      this.setWritable(stream);\n    }\n    if (this._isCancelCalled && this.stream) {\n      this.stream.cancel();\n    }\n  }\n  /**\n   * Creates a new retry request stream -\n   *inner arrow function \"newMakeRequest\" handles retrying and resumption\n   * @param {streamingRetryRequestOptions} opts\n   *   {request} - the request to be made if the stream errors\n   *   {retry} - the retry options associated with the call\n   * @returns {CancellableStream} - the stream that handles retry logic\n   */\n  newStreamingRetryRequest(opts) {\n    var _a, _b, _c, _d;\n    // at this point, it would be unexpected if retry were undefined\n    // but if it is, provide a logical default so we don't run into trouble\n    const retry = (_a = opts.retry) !== null && _a !== void 0 ? _a : {\n      retryCodes: [],\n      backoffSettings: (0, gax_1.createDefaultBackoffSettings)()\n    };\n    let retries = 0;\n    const retryStream = new stream_1.PassThrough({\n      objectMode: true\n    });\n    const totalTimeout = (_b = retry.backoffSettings.totalTimeoutMillis) !== null && _b !== void 0 ? _b : undefined;\n    const maxRetries = (_c = retry.backoffSettings.maxRetries) !== null && _c !== void 0 ? _c : undefined;\n    let timeout = (_d = retry.backoffSettings.initialRpcTimeoutMillis) !== null && _d !== void 0 ? _d : undefined;\n    let now = new Date();\n    let deadline = 0;\n    if (totalTimeout) {\n      deadline = now.getTime() + totalTimeout;\n    }\n    const transientErrorHelper = (error, requestStream) => {\n      const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n      e.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n      // clean up the request stream and retryStreams, silently destroy it on the request stream\n      // but do raise it on destructin of the retryStream so the consumer can see it\n      requestStream.destroy();\n      retryStream.destroy(e);\n      return retryStream;\n    };\n    const newMakeRequest = newopts => {\n      let dataEnd = false;\n      let statusReceived = false;\n      let enteredError = false;\n      // make the request\n      const requestStream = newopts.request(requestOps);\n      retryStream.cancel = requestStream.cancel; // make sure the retryStream is also cancellable by the user\n      const eventsToForward = ['metadata', 'response', 'status'];\n      eventsToForward.forEach(event => {\n        requestStream.on(event, retryStream.emit.bind(retryStream, event));\n      });\n      this.statusMetadataHelper(requestStream);\n      // TODO - b/353262542 address buffer stuff\n      requestStream.on('data', data => {\n        retries = 0;\n        this.emit.bind(this, 'data')(data);\n      });\n      /* in retry-request, which previously handled retries,\n       * \"end\" could be emitted on a request stream before other gRPC events.\n       * To ensure it doesn't reach the consumer stream prematurely, retry-request piped\n       * two streams together (delayStream and retryStream)\n       * to ensure that \"end\" only emitted after a \"response\" event\n       *\n       * We are consciously NOT using pipeline or .pipe as part of similar logic here\n       * because we want more control over what happens during event handoff and we want to\n       * avoid the undesired behavior that can happen with error events\n       * if consumers in client libraries are also using pipes\n       *\n       * Since \"status\" is guaranteed to be the last event emitted by gRPC.\n       * If we have seen an \"end\" event, the dataEnd boolean will be true and we can safely\n       * end the stream.\n       *\n       * The \"statusReceived\" boolean covers the opposite case - that we receive the \"status\" event before\n       * a successful stream end event - this signals the .on('end') event handler that it's okay to end the stream\n       *\n       *\n       */\n      requestStream.on('status', () => {\n        statusReceived = true;\n        if (dataEnd) {\n          retryStream.end();\n        }\n        return retryStream;\n      });\n      requestStream.on('end', () => {\n        if (!enteredError) {\n          dataEnd = true;\n          // in this case, we've already received \"status\"\n          // which is the last event from gRPC, so it's cool to end the stream\n          if (statusReceived) {\n            retryStream.end();\n          }\n        }\n        return retryStream;\n        // there is no else case because if enteredError\n        // is true, we will handle stream destruction as part of\n        // either retrying (where we don't want to end the stream)\n        // or as part of error handling, which will take care of stream destruction\n      });\n      requestStream.on('error', error => {\n        enteredError = true;\n        // type check for undefined instead of for truthiness in case maxRetries or timeout is equal to zero\n        if (typeof maxRetries !== undefined || typeof totalTimeout !== undefined) {\n          if (this.shouldRetryRequest(error, retry)) {\n            if (maxRetries && totalTimeout) {\n              const newError = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n              newError.code = status_1.Status.INVALID_ARGUMENT;\n              // clean up the request stream and retryStreams, silently destroy it on the request stream\n              // but do raise it on destructin of the retryStream so the consumer can see it\n              requestStream.destroy();\n              retryStream.destroy(newError);\n              return retryStream;\n            } else {\n              // check for exceeding timeout or max retries\n              try {\n                this.throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, timeout, error, totalTimeout, retries);\n              } catch (error) {\n                const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n                // clean up the request stream and retryStreams, silently destroy it on the request stream\n                // but do raise it on destruction of the retryStream so the consumer can see it\n                requestStream.destroy();\n                retryStream.destroy(e);\n                return retryStream;\n              }\n              const delayMult = retry.backoffSettings.retryDelayMultiplier;\n              const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n              const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n              const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n              let delay = retry.backoffSettings.initialRetryDelayMillis;\n              // calculate new deadlines\n              const toSleep = Math.random() * delay;\n              const calculateTimeoutAndResumptionFunction = () => {\n                setTimeout(() => {\n                  // only do timeout calculations if not using maxRetries\n                  if (timeout) {\n                    now = new Date();\n                    delay = Math.min(delay * delayMult, maxDelay);\n                    const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                    const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                    const newDeadline = deadline ? deadline - now.getTime() : 0;\n                    timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n                  }\n                  retries++;\n                  let retryArgument = this.argument;\n                  // if resumption logic is passed, use it to determined the\n                  // new argument for the new request made to the server\n                  // otherwise, the original argument will be passed\n                  if (retry.getResumptionRequestFn !== undefined) {\n                    retryArgument = retry.getResumptionRequestFn(retryArgument);\n                  }\n                  const newRequest = () => {\n                    if (this._isCancelCalled) {\n                      if (this.stream) {\n                        this.stream.cancel();\n                      }\n                      return;\n                    }\n                    const newStream = this.apiCall(retryArgument, this._callback);\n                    return newStream;\n                  };\n                  opts.request = newRequest;\n                  // make a request with the updated parameters\n                  // based on the resumption strategy\n                  return newMakeRequest(opts);\n                }, toSleep);\n              };\n              return calculateTimeoutAndResumptionFunction();\n            }\n          } else {\n            // non retryable error\n            return transientErrorHelper(error, requestStream);\n          }\n        } else {\n          // neither timeout nor maxRetries are defined, surface the error to the caller\n          return transientErrorHelper(error, requestStream);\n        }\n      });\n      // return the stream if we didn't return it as\n      // part of an error state\n      return retryStream;\n    };\n    // this is the first make request call with the options the user passed in\n    return newMakeRequest(opts);\n  }\n}\nexports.StreamProxy = StreamProxy;","map":{"version":3,"names":["gax_1","require","googleError_1","status_1","stream_1","duplexify","retryRequest","StreamType","exports","requestOps","StreamProxy","constructor","type","callback","rest","gaxServerStreamingRetries","undefined","objectMode","readable","CLIENT_STREAMING","writable","SERVER_STREAMING","_callback","_isCancelCalled","_responseHasSent","shouldRetryRequest","error","retry","e","GoogleError","parseGRPCStatusDetails","shouldRetry","defaultShouldRetry","shouldRetryFn","cancel","stream","throwIfMaxRetriesOrTotalTimeoutExceeded","deadline","maxRetries","totalTimeoutMillis","originalError","originalTimeout","retries","now","Date","nowTime","getTime","code","Status","DEADLINE_EXCEEDED","note","eventForwardHelper","eventsToForward","forEach","event","on","emit","bind","statusMetadataHelper","details","message","metadata","forwardEvents","retryCodes","length","indexOf","setStream","apiCall","argument","retryRequestOptions","setReadable","request","retryStream","newStreamingRetryRequest","currentRetryAttempt","noResponseRetries","setWritable","BIDI_STREAMING","opts","_a","backoffSettings","createDefaultBackoffSettings","PassThrough","totalTimeout","_b","_c","timeout","_d","initialRpcTimeoutMillis","transientErrorHelper","requestStream","destroy","newMakeRequest","newopts","dataEnd","statusReceived","enteredError","data","end","newError","INVALID_ARGUMENT","delayMult","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","toSleep","Math","random","calculateTimeoutAndResumptionFunction","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","retryArgument","getResumptionRequestFn","newRequest","newStream"],"sources":["../../../src/streamingCalls/streaming.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}