{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createApiCall = createApiCall;\n/**\n * Provides function wrappers that implement page streaming and retrying.\n */\nconst apiCaller_1 = require(\"./apiCaller\");\nconst gax_1 = require(\"./gax\");\nconst retries_1 = require(\"./normalCalls/retries\");\nconst timeout_1 = require(\"./normalCalls/timeout\");\nconst streamingApiCaller_1 = require(\"./streamingCalls/streamingApiCaller\");\nconst warnings_1 = require(\"./warnings\");\n/**\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promise to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * @param {Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make\n *   a bare RPC call, or just a bare RPC call.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Descriptor} descriptor - optionally specify the descriptor for\n *   the method call.\n * @return {GaxCall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\nfunction createApiCall(func, settings, descriptor,\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_fallback // unused here, used in fallback.ts implementation\n) {\n  // we want to be able to accept both promise resolving to a function and a\n  // function. Currently client librares are only calling this method with a\n  // promise, but it will change.\n  const funcPromise = typeof func === 'function' ? Promise.resolve(func) : func;\n  // the following apiCaller will be used for all calls of this function...\n  const apiCaller = (0, apiCaller_1.createAPICaller)(settings, descriptor);\n  return (request, callOptions, callback) => {\n    var _a, _b;\n    let currentApiCaller = apiCaller;\n    let thisSettings;\n    if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\n      const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null && _b !== void 0 ? _b : false;\n      // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\n      const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\n      thisSettings = settings.merge(convertedRetryOptions);\n    } else {\n      thisSettings = settings.merge(callOptions);\n    }\n    // special case: if bundling is disabled for this one call,\n    // use default API caller instead\n    if (settings.isBundling && !thisSettings.isBundling) {\n      currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\n    }\n    const ongoingCall = currentApiCaller.init(callback);\n    funcPromise.then(func => {\n      var _a, _b;\n      var _c;\n      // Initially, the function is just what gRPC server stub contains.\n      func = currentApiCaller.wrap(func);\n      const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\n      const retry = thisSettings.retry;\n      if (streaming && retry) {\n        if (retry.retryCodes.length > 0 && retry.shouldRetryFn) {\n          (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\n          retry.retryCodes = [];\n        }\n        if (!currentApiCaller.descriptor.gaxStreamingRetries && retry.getResumptionRequestFn) {\n          throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\n        }\n      }\n      if (!streaming && retry) {\n        if (retry.shouldRetryFn) {\n          throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\n        }\n        if (retry.getResumptionRequestFn) {\n          throw new Error('Resumption strategy can only be used with server streaming retries');\n        }\n        if (retry.retryCodes && retry.retryCodes.length > 0) {\n          (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null && _b !== void 0 ? _b : _c.initialRpcTimeoutMillis = thisSettings.timeout;\n          return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\n        }\n      }\n      return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\n    }).then(apiCall => {\n      // After adding retries / timeouts, the call function becomes simpler:\n      // it only accepts request and callback.\n      currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\n    }).catch(err => {\n      currentApiCaller.fail(ongoingCall, err);\n    });\n    // Calls normally return a \"cancellable promise\" that can be used to `await` for the actual result,\n    // or to cancel the ongoing call.\n    return currentApiCaller.result(ongoingCall);\n  };\n}","map":{"version":3,"names":["exports","createApiCall","apiCaller_1","require","gax_1","retries_1","timeout_1","streamingApiCaller_1","warnings_1","func","settings","descriptor","_fallback","funcPromise","Promise","resolve","apiCaller","createAPICaller","request","callOptions","callback","currentApiCaller","thisSettings","StreamingApiCaller","gaxStreamingRetries","_b","_a","convertedRetryOptions","convertRetryOptions","merge","isBundling","undefined","ongoingCall","init","then","wrap","streaming","retry","retryCodes","length","shouldRetryFn","warn","getResumptionRequestFn","Error","_c","backoffSettings","initialRpcTimeoutMillis","timeout","retryable","otherArgs","apiName","addTimeoutArg","apiCall","call","catch","err","fail","result"],"sources":["../../src/createApiCall.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}