{"ast":null,"code":"/*! firebase-admin v13.6.1 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.IAMSigner = exports.ServiceAccountSigner = void 0;\nexports.cryptoSignerFromApp = cryptoSignerFromApp;\nconst credential_internal_1 = require(\"../app/credential-internal\");\nconst api_request_1 = require(\"./api-request\");\nconst utils = require(\"../utils/index\");\nconst validator = require(\"../utils/validator\");\nconst ALGORITHM_RS256 = 'RS256';\n/**\n * A CryptoSigner implementation that uses an explicitly specified service account private key to\n * sign data. Performs all operations locally, and does not make any RPC calls.\n */\nclass ServiceAccountSigner {\n  /**\n   * Creates a new CryptoSigner instance from the given service account credential.\n   *\n   * @param credential - A service account credential.\n   */\n  constructor(credential) {\n    this.credential = credential;\n    this.algorithm = ALGORITHM_RS256;\n    if (!credential) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n        message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.'\n      });\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  sign(buffer) {\n    const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires\n    const sign = crypto.createSign('RSA-SHA256');\n    sign.update(buffer);\n    return Promise.resolve(sign.sign(this.credential.privateKey));\n  }\n  /**\n   * @inheritDoc\n   */\n  getAccountId() {\n    return Promise.resolve(this.credential.clientEmail);\n  }\n}\nexports.ServiceAccountSigner = ServiceAccountSigner;\n/**\n * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without\n * a service account ID, attempts to discover a service account ID by consulting the local Metadata\n * service. This will succeed in managed environments like Google Cloud Functions and App Engine.\n *\n * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob\n * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata\n */\nclass IAMSigner {\n  constructor(httpClient, app) {\n    this.algorithm = ALGORITHM_RS256;\n    if (!httpClient) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n        message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.'\n      });\n    }\n    if (app && (typeof app !== 'object' || app === null || !('options' in app))) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n        message: 'INTERNAL ASSERT: Must provide a valid Firebase app instance.'\n      });\n    }\n    this.httpClient = httpClient;\n    this.app = app;\n  }\n  /**\n   * @inheritDoc\n   */\n  sign(buffer) {\n    return this.getAccountId().then(serviceAccount => {\n      const request = {\n        method: 'POST',\n        url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,\n        data: {\n          payload: buffer.toString('base64')\n        }\n      };\n      return this.httpClient.send(request);\n    }).then(response => {\n      // Response from IAM is base64 encoded. Decode it into a buffer and return.\n      return Buffer.from(response.data.signedBlob, 'base64');\n    }).catch(err => {\n      if (err instanceof api_request_1.RequestResponseError) {\n        throw new CryptoSignerError({\n          code: CryptoSignerErrorCode.SERVER_ERROR,\n          message: err.message,\n          cause: err\n        });\n      }\n      throw err;\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n  async getAccountId() {\n    if (validator.isNonEmptyString(this.serviceAccountId)) {\n      return this.serviceAccountId;\n    }\n    if (this.app) {\n      const accountId = await utils.findServiceAccountEmail(this.app);\n      if (accountId) {\n        this.serviceAccountId = accountId;\n        return accountId;\n      }\n    }\n    const request = {\n      method: 'GET',\n      url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',\n      headers: {\n        'Metadata-Flavor': 'Google'\n      }\n    };\n    const client = new api_request_1.HttpClient();\n    return client.send(request).then(response => {\n      if (!response.text) {\n        throw new CryptoSignerError({\n          code: CryptoSignerErrorCode.INTERNAL_ERROR,\n          message: 'HTTP Response missing payload'\n        });\n      }\n      this.serviceAccountId = response.text;\n      return response.text;\n    }).catch(err => {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n        message: 'Failed to determine service account. Make sure to initialize ' + 'the SDK with a service account credential. Alternatively specify a service ' + `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`\n      });\n    });\n  }\n}\nexports.IAMSigner = IAMSigner;\n/**\n * Creates a new CryptoSigner instance for the given app. If the app has been initialized with a\n * service account credential, creates a ServiceAccountSigner.\n *\n * @param app - A FirebaseApp instance.\n * @returns A CryptoSigner instance.\n */\nfunction cryptoSignerFromApp(app) {\n  const credential = app.options.credential;\n  if (credential instanceof credential_internal_1.ServiceAccountCredential) {\n    return new ServiceAccountSigner(credential);\n  }\n  return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app);\n}\n/**\n * CryptoSigner error code structure.\n *\n * @param errorInfo - The error information (code and message).\n * @constructor\n */\nclass CryptoSignerError extends Error {\n  constructor(errorInfo) {\n    super(errorInfo.message);\n    this.errorInfo = errorInfo;\n    /* tslint:disable:max-line-length */\n    // Set the prototype explicitly. See the following link for more details:\n    // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    /* tslint:enable:max-line-length */\n    this.__proto__ = CryptoSignerError.prototype;\n  }\n  /** @returns The error code. */\n  get code() {\n    return this.errorInfo.code;\n  }\n  /** @returns The error message. */\n  get message() {\n    return this.errorInfo.message;\n  }\n  /** @returns The error data. */\n  get cause() {\n    return this.errorInfo.cause;\n  }\n}\nexports.CryptoSignerError = CryptoSignerError;\n/**\n * Crypto Signer error codes and their default messages.\n */\nclass CryptoSignerErrorCode {}\nexports.CryptoSignerErrorCode = CryptoSignerErrorCode;\nCryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';\nCryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';\nCryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';\nCryptoSignerErrorCode.SERVER_ERROR = 'server-error';","map":{"version":3,"names":["Object","defineProperty","exports","value","CryptoSignerErrorCode","CryptoSignerError","IAMSigner","ServiceAccountSigner","cryptoSignerFromApp","credential_internal_1","require","api_request_1","utils","validator","ALGORITHM_RS256","constructor","credential","algorithm","code","INVALID_CREDENTIAL","message","sign","buffer","crypto","createSign","update","Promise","resolve","privateKey","getAccountId","clientEmail","httpClient","app","INVALID_ARGUMENT","then","serviceAccount","request","method","url","data","payload","toString","send","response","Buffer","from","signedBlob","catch","err","RequestResponseError","SERVER_ERROR","cause","isNonEmptyString","serviceAccountId","accountId","findServiceAccountEmail","headers","client","HttpClient","text","INTERNAL_ERROR","options","ServiceAccountCredential","AuthorizedHttpClient","Error","errorInfo","__proto__","prototype"],"sources":["C:/Users/PROGRAMMER/Desktop/goal tracker app clone/goal-tracker-app/client/node_modules/firebase-admin/lib/utils/crypto-signer.js"],"sourcesContent":["/*! firebase-admin v13.6.1 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.IAMSigner = exports.ServiceAccountSigner = void 0;\nexports.cryptoSignerFromApp = cryptoSignerFromApp;\nconst credential_internal_1 = require(\"../app/credential-internal\");\nconst api_request_1 = require(\"./api-request\");\nconst utils = require(\"../utils/index\");\nconst validator = require(\"../utils/validator\");\nconst ALGORITHM_RS256 = 'RS256';\n/**\n * A CryptoSigner implementation that uses an explicitly specified service account private key to\n * sign data. Performs all operations locally, and does not make any RPC calls.\n */\nclass ServiceAccountSigner {\n    /**\n     * Creates a new CryptoSigner instance from the given service account credential.\n     *\n     * @param credential - A service account credential.\n     */\n    constructor(credential) {\n        this.credential = credential;\n        this.algorithm = ALGORITHM_RS256;\n        if (!credential) {\n            throw new CryptoSignerError({\n                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n                message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.',\n            });\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    sign(buffer) {\n        const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires\n        const sign = crypto.createSign('RSA-SHA256');\n        sign.update(buffer);\n        return Promise.resolve(sign.sign(this.credential.privateKey));\n    }\n    /**\n     * @inheritDoc\n     */\n    getAccountId() {\n        return Promise.resolve(this.credential.clientEmail);\n    }\n}\nexports.ServiceAccountSigner = ServiceAccountSigner;\n/**\n * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without\n * a service account ID, attempts to discover a service account ID by consulting the local Metadata\n * service. This will succeed in managed environments like Google Cloud Functions and App Engine.\n *\n * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob\n * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata\n */\nclass IAMSigner {\n    constructor(httpClient, app) {\n        this.algorithm = ALGORITHM_RS256;\n        if (!httpClient) {\n            throw new CryptoSignerError({\n                code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n                message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.',\n            });\n        }\n        if (app && (typeof app !== 'object' || app === null || !('options' in app))) {\n            throw new CryptoSignerError({\n                code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n                message: 'INTERNAL ASSERT: Must provide a valid Firebase app instance.',\n            });\n        }\n        this.httpClient = httpClient;\n        this.app = app;\n    }\n    /**\n     * @inheritDoc\n     */\n    sign(buffer) {\n        return this.getAccountId().then((serviceAccount) => {\n            const request = {\n                method: 'POST',\n                url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,\n                data: { payload: buffer.toString('base64') },\n            };\n            return this.httpClient.send(request);\n        }).then((response) => {\n            // Response from IAM is base64 encoded. Decode it into a buffer and return.\n            return Buffer.from(response.data.signedBlob, 'base64');\n        }).catch((err) => {\n            if (err instanceof api_request_1.RequestResponseError) {\n                throw new CryptoSignerError({\n                    code: CryptoSignerErrorCode.SERVER_ERROR,\n                    message: err.message,\n                    cause: err\n                });\n            }\n            throw err;\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    async getAccountId() {\n        if (validator.isNonEmptyString(this.serviceAccountId)) {\n            return this.serviceAccountId;\n        }\n        if (this.app) {\n            const accountId = await utils.findServiceAccountEmail(this.app);\n            if (accountId) {\n                this.serviceAccountId = accountId;\n                return accountId;\n            }\n        }\n        const request = {\n            method: 'GET',\n            url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',\n            headers: {\n                'Metadata-Flavor': 'Google',\n            },\n        };\n        const client = new api_request_1.HttpClient();\n        return client.send(request).then((response) => {\n            if (!response.text) {\n                throw new CryptoSignerError({\n                    code: CryptoSignerErrorCode.INTERNAL_ERROR,\n                    message: 'HTTP Response missing payload',\n                });\n            }\n            this.serviceAccountId = response.text;\n            return response.text;\n        }).catch((err) => {\n            throw new CryptoSignerError({\n                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n                message: 'Failed to determine service account. Make sure to initialize ' +\n                    'the SDK with a service account credential. Alternatively specify a service ' +\n                    `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`,\n            });\n        });\n    }\n}\nexports.IAMSigner = IAMSigner;\n/**\n * Creates a new CryptoSigner instance for the given app. If the app has been initialized with a\n * service account credential, creates a ServiceAccountSigner.\n *\n * @param app - A FirebaseApp instance.\n * @returns A CryptoSigner instance.\n */\nfunction cryptoSignerFromApp(app) {\n    const credential = app.options.credential;\n    if (credential instanceof credential_internal_1.ServiceAccountCredential) {\n        return new ServiceAccountSigner(credential);\n    }\n    return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app);\n}\n/**\n * CryptoSigner error code structure.\n *\n * @param errorInfo - The error information (code and message).\n * @constructor\n */\nclass CryptoSignerError extends Error {\n    constructor(errorInfo) {\n        super(errorInfo.message);\n        this.errorInfo = errorInfo;\n        /* tslint:disable:max-line-length */\n        // Set the prototype explicitly. See the following link for more details:\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        /* tslint:enable:max-line-length */\n        this.__proto__ = CryptoSignerError.prototype;\n    }\n    /** @returns The error code. */\n    get code() {\n        return this.errorInfo.code;\n    }\n    /** @returns The error message. */\n    get message() {\n        return this.errorInfo.message;\n    }\n    /** @returns The error data. */\n    get cause() {\n        return this.errorInfo.cause;\n    }\n}\nexports.CryptoSignerError = CryptoSignerError;\n/**\n * Crypto Signer error codes and their default messages.\n */\nclass CryptoSignerErrorCode {\n}\nexports.CryptoSignerErrorCode = CryptoSignerErrorCode;\nCryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';\nCryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';\nCryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';\nCryptoSignerErrorCode.SERVER_ERROR = 'server-error';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}