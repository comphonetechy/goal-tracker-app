{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientPool = exports.CLIENT_TERMINATED_ERROR_MSG = void 0;\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\nconst util_1 = require(\"./util\");\nexports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n * @internal\n */\nclass ClientPool {\n  /**\n   * @param concurrentOperationLimit The number of operations that each client\n   * can handle.\n   * @param maxIdleClients The maximum number of idle clients to keep before\n   * garbage collecting.\n   * @param clientFactory A factory function called as needed when new clients\n   * are required.\n   * @param clientDestructor A cleanup function that is called when a client is\n   * disposed of.\n   */\n  constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n    this.concurrentOperationLimit = concurrentOperationLimit;\n    this.maxIdleClients = maxIdleClients;\n    this.clientFactory = clientFactory;\n    this.clientDestructor = clientDestructor;\n    this.grpcEnabled = false;\n    /**\n     * Stores each active clients and how many operations it has outstanding.\n     */\n    this.activeClients = new Map();\n    /**\n     * A set of clients that have seen RST_STREAM errors (see\n     * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\n     * no longer be used.\n     */\n    this.failedClients = new Set();\n    /**\n     * A mapping from \"client\" objects to their corresponding IDs. These IDs have\n     * no semantic meaning but are used for logging to enable tracing the events\n     * of a particular client over time (such as creating, acquiring, and\n     * releasing).\n     */\n    this.clientIdByClient = new WeakMap();\n    /**\n     * Whether the Firestore instance has been terminated. Once terminated, the\n     * ClientPool can longer schedule new operations.\n     */\n    this.terminated = false;\n    /**\n     * Deferred promise that is resolved when there are no active operations on\n     * the client pool after terminate() has been called.\n     */\n    this.terminateDeferred = new util_1.Deferred();\n    /**\n     * A unique identifier for this object, for inclusion in log messages.\n     */\n    this.instanceId = 'cpl' + (0, util_1.requestTag)();\n    this.lazyLogStringForAllClientIds = new LazyLogStringForAllClientIds({\n      activeClients: this.activeClients,\n      failedClients: this.failedClients,\n      clientIdByClient: this.clientIdByClient\n    });\n  }\n  /**\n   * Returns an already existing client if it has less than the maximum number\n   * of concurrent operations or initializes and returns a new client.\n   *\n   * @private\n   * @internal\n   */\n  acquire(requestTag, requiresGrpc) {\n    let selectedClient = null;\n    let selectedClientRequestCount = -1;\n    // Transition to grpc when we see the first operation that requires grpc.\n    this.grpcEnabled = this.grpcEnabled || requiresGrpc;\n    // Require a grpc client for this operation if we have transitioned to grpc.\n    requiresGrpc = requiresGrpc || this.grpcEnabled;\n    for (const [client, metadata] of this.activeClients) {\n      // Use the \"most-full\" client that can still accommodate the request\n      // in order to maximize the number of idle clients as operations start to\n      // complete.\n      if (!this.failedClients.has(client) && metadata.activeRequestCount > selectedClientRequestCount && metadata.activeRequestCount < this.concurrentOperationLimit && (metadata.grpcEnabled || !requiresGrpc)) {\n        selectedClient = client;\n        selectedClientRequestCount = metadata.activeRequestCount;\n      }\n    }\n    if (selectedClient) {\n      const selectedClientId = this.clientIdByClient.get(selectedClient);\n      (0, logger_1.logger)(`ClientPool[${this.instanceId}].acquire`, requestTag, 'Re-using existing client [%s] with %s remaining operations', selectedClientId, this.concurrentOperationLimit - selectedClientRequestCount);\n    } else {\n      const newClientId = 'cli' + (0, util_1.requestTag)();\n      (0, logger_1.logger)(`ClientPool[${this.instanceId}].acquire`, requestTag, 'Creating a new client [%s] (requiresGrpc: %s)', newClientId, requiresGrpc);\n      selectedClient = this.clientFactory(requiresGrpc);\n      this.clientIdByClient.set(selectedClient, newClientId);\n      selectedClientRequestCount = 0;\n      assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n    }\n    this.activeClients.set(selectedClient, {\n      grpcEnabled: requiresGrpc,\n      activeRequestCount: selectedClientRequestCount + 1\n    });\n    return selectedClient;\n  }\n  /**\n   * Reduces the number of operations for the provided client, potentially\n   * removing it from the pool of active clients.\n   * @private\n   * @internal\n   */\n  async release(requestTag, client) {\n    const clientId = this.clientIdByClient.get(client);\n    const metadata = this.activeClients.get(client);\n    assert(metadata && metadata.activeRequestCount > 0, 'No active requests');\n    this.activeClients.set(client, {\n      grpcEnabled: metadata.grpcEnabled,\n      activeRequestCount: metadata.activeRequestCount - 1\n    });\n    if (this.terminated && this.opCount === 0) {\n      this.terminateDeferred.resolve();\n    }\n    const gcDetermination = this.shouldGarbageCollectClient(client);\n    (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Releasing client [%s] (gc=%s)', clientId, gcDetermination);\n    if (!gcDetermination.shouldGarbageCollectClient) {\n      return;\n    }\n    (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Garbage collecting client [%s] (%s)', clientId, this.lazyLogStringForAllClientIds);\n    const activeClientDeleted = this.activeClients.delete(client);\n    this.failedClients.delete(client);\n    await this.clientDestructor(client);\n    (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Garbage collected client [%s] activeClientDeleted=%s (%s)', clientId, activeClientDeleted, this.lazyLogStringForAllClientIds);\n  }\n  /**\n   * Given the current operation counts, determines if the given client should\n   * be garbage collected.\n   * @private\n   * @internal\n   */\n  shouldGarbageCollectClient(client) {\n    const clientMetadata = this.activeClients.get(client);\n    if (clientMetadata.activeRequestCount !== 0) {\n      // Don't garbage collect clients that have active requests.\n      return new ClientHasActiveRequests({\n        shouldGarbageCollectClient: false,\n        clientActiveRequestCount: clientMetadata.activeRequestCount\n      });\n    }\n    if (this.grpcEnabled !== clientMetadata.grpcEnabled) {\n      // We are transitioning to GRPC. Garbage collect REST clients.\n      return new PoolIsTransitioningToGrpc({\n        shouldGarbageCollectClient: true,\n        clientActiveRequestCount: clientMetadata.activeRequestCount,\n        poolGrpcEnabled: this.grpcEnabled,\n        clientGrpcEnabled: clientMetadata.grpcEnabled\n      });\n    }\n    // Idle clients that have received RST_STREAM errors are always garbage\n    // collected.\n    if (this.failedClients.has(client)) {\n      return new ClientIsFailed({\n        shouldGarbageCollectClient: true,\n        clientActiveRequestCount: clientMetadata.activeRequestCount\n      });\n    }\n    // Otherwise, only garbage collect if we have too much idle capacity (e.g.\n    // more than 100 idle capacity with default settings).\n    let idleCapacityCount = 0;\n    for (const [, metadata] of this.activeClients) {\n      idleCapacityCount += this.concurrentOperationLimit - metadata.activeRequestCount;\n    }\n    const maxIdleCapacityCount = this.maxIdleClients * this.concurrentOperationLimit;\n    return new IdleCapacity({\n      shouldGarbageCollectClient: idleCapacityCount > maxIdleCapacityCount,\n      clientActiveRequestCount: clientMetadata.activeRequestCount,\n      idleCapacityCount: idleCapacityCount,\n      maxIdleCapacityCount: maxIdleCapacityCount,\n      maxIdleClients: this.maxIdleClients,\n      concurrentOperationLimit: this.concurrentOperationLimit\n    });\n  }\n  /**\n   * The number of currently registered clients.\n   *\n   * @return Number of currently registered clients.\n   * @private\n   * @internal\n   */\n  // Visible for testing.\n  get size() {\n    return this.activeClients.size;\n  }\n  /**\n   * The number of currently active operations.\n   *\n   * @return Number of currently active operations.\n   * @private\n   * @internal\n   */\n  // Visible for testing.\n  get opCount() {\n    let activeOperationCount = 0;\n    this.activeClients.forEach(metadata => activeOperationCount += metadata.activeRequestCount);\n    return activeOperationCount;\n  }\n  /**\n   * The currently active clients.\n   *\n   * @return The currently active clients.\n   * @private\n   * @internal\n   */\n  // Visible for testing.\n  get _activeClients() {\n    return this.activeClients;\n  }\n  /**\n   * Runs the provided operation in this pool. This function may create an\n   * additional client if all existing clients already operate at the concurrent\n   * operation limit.\n   *\n   * @param requestTag A unique client-assigned identifier for this operation.\n   * @param op A callback function that returns a Promise. The client T will\n   * be returned to the pool when callback finishes.\n   * @return A Promise that resolves with the result of `op`.\n   * @private\n   * @internal\n   */\n  run(requestTag, requiresGrpc, op) {\n    if (this.terminated) {\n      return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\n    }\n    const client = this.acquire(requestTag, requiresGrpc);\n    return op(client).catch(async err => {\n      var _a;\n      if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\n        // Once a client has seen a RST_STREAM error, the GRPC channel can\n        // no longer be used. We mark the client as failed, which ensures that\n        // we open a new GRPC channel for the next request.\n        this.failedClients.add(client);\n      }\n      await this.release(requestTag, client);\n      return Promise.reject(err);\n    }).then(async res => {\n      await this.release(requestTag, client);\n      return res;\n    });\n  }\n  async terminate() {\n    this.terminated = true;\n    // Wait for all pending operations to complete before terminating.\n    if (this.opCount > 0) {\n      (0, logger_1.logger)(`ClientPool[${this.instanceId}].terminate`, /* requestTag= */null, 'Waiting for %s pending operations to complete before terminating (%s)', this.opCount, this.lazyLogStringForAllClientIds);\n      await this.terminateDeferred.promise;\n    }\n    (0, logger_1.logger)(`ClientPool[${this.instanceId}].terminate`, /* requestTag= */null, 'Closing all active clients (%s)', this.lazyLogStringForAllClientIds);\n    for (const [client] of this.activeClients) {\n      this.activeClients.delete(client);\n      await this.clientDestructor(client);\n    }\n  }\n}\nexports.ClientPool = ClientPool;\n/**\n * Helper class that, when logged as a direct argument of `logger()`, will\n * lazily evaluate to a long string that contains all IDs of both active and\n * failed clients.\n */\nclass LazyLogStringForAllClientIds {\n  constructor(config) {\n    this.activeClients = config.activeClients;\n    this.failedClients = config.failedClients;\n    this.clientIdByClient = config.clientIdByClient;\n  }\n  toString() {\n    const activeClientsDescription = Array.from(this.activeClients.entries()).map(([client, metadata]) => `${this.clientIdByClient.get(client)}=${metadata.activeRequestCount}`).sort().join(', ');\n    const failedClientsDescription = Array.from(this.failedClients).map(client => `${this.clientIdByClient.get(client)}`).sort().join(', ');\n    return `${this.activeClients.size} active clients: {` + activeClientsDescription + '}, ' + `${this.failedClients.size} failed clients: {` + failedClientsDescription + '}';\n  }\n}\n/**\n * Minimum data to be included in the objects returned from\n * ClientPool.shouldGarbageCollectClient().\n */\nclass BaseShouldGarbageCollectClientResult {\n  /**\n   * Return a terse, one-line string representation. This makes it easy to\n   * grep through log output to find the logged values.\n   */\n  toString() {\n    const propertyStrings = [];\n    for (const propertyName of Object.getOwnPropertyNames(this)) {\n      const propertyValue = this[propertyName];\n      propertyStrings.push(`${propertyName}=${propertyValue}`);\n    }\n    return '{' + propertyStrings.join(', ') + '}';\n  }\n}\nclass ClientHasActiveRequests extends BaseShouldGarbageCollectClientResult {\n  constructor(args) {\n    super();\n    this.name = 'ClientHasActiveRequests';\n    this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;\n    this.clientActiveRequestCount = args.clientActiveRequestCount;\n  }\n}\nclass PoolIsTransitioningToGrpc extends BaseShouldGarbageCollectClientResult {\n  constructor(args) {\n    super();\n    this.name = 'PoolIsTransitioningToGrpc';\n    this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;\n    this.clientActiveRequestCount = args.clientActiveRequestCount;\n    this.poolGrpcEnabled = args.poolGrpcEnabled;\n    this.clientGrpcEnabled = args.clientGrpcEnabled;\n  }\n}\nclass ClientIsFailed extends BaseShouldGarbageCollectClientResult {\n  constructor(args) {\n    super();\n    this.name = 'ClientIsFailed';\n    this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;\n    this.clientActiveRequestCount = args.clientActiveRequestCount;\n  }\n}\nclass IdleCapacity extends BaseShouldGarbageCollectClientResult {\n  constructor(args) {\n    super();\n    this.name = 'IdleCapacity';\n    this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;\n    this.clientActiveRequestCount = args.clientActiveRequestCount;\n    this.idleCapacityCount = args.idleCapacityCount;\n    this.maxIdleCapacityCount = args.maxIdleCapacityCount;\n    this.maxIdleClients = args.maxIdleClients;\n    this.concurrentOperationLimit = args.concurrentOperationLimit;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ClientPool","CLIENT_TERMINATED_ERROR_MSG","assert","require","logger_1","util_1","constructor","concurrentOperationLimit","maxIdleClients","clientFactory","clientDestructor","Promise","resolve","grpcEnabled","activeClients","Map","failedClients","Set","clientIdByClient","WeakMap","terminated","terminateDeferred","Deferred","instanceId","requestTag","lazyLogStringForAllClientIds","LazyLogStringForAllClientIds","acquire","requiresGrpc","selectedClient","selectedClientRequestCount","client","metadata","has","activeRequestCount","selectedClientId","get","logger","newClientId","set","release","clientId","opCount","gcDetermination","shouldGarbageCollectClient","activeClientDeleted","delete","clientMetadata","ClientHasActiveRequests","clientActiveRequestCount","PoolIsTransitioningToGrpc","poolGrpcEnabled","clientGrpcEnabled","ClientIsFailed","idleCapacityCount","maxIdleCapacityCount","IdleCapacity","size","activeOperationCount","forEach","_activeClients","run","op","reject","Error","catch","err","_a","message","match","add","then","res","terminate","promise","config","toString","activeClientsDescription","Array","from","entries","map","sort","join","failedClientsDescription","BaseShouldGarbageCollectClientResult","propertyStrings","propertyName","getOwnPropertyNames","propertyValue","push","args","name"],"sources":["C:/Users/PROGRAMMER/Desktop/goal tracker app clone/goal-tracker-app/client/node_modules/@google-cloud/firestore/build/src/pool.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientPool = exports.CLIENT_TERMINATED_ERROR_MSG = void 0;\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\nconst util_1 = require(\"./util\");\nexports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n * @internal\n */\nclass ClientPool {\n    /**\n     * @param concurrentOperationLimit The number of operations that each client\n     * can handle.\n     * @param maxIdleClients The maximum number of idle clients to keep before\n     * garbage collecting.\n     * @param clientFactory A factory function called as needed when new clients\n     * are required.\n     * @param clientDestructor A cleanup function that is called when a client is\n     * disposed of.\n     */\n    constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n        this.concurrentOperationLimit = concurrentOperationLimit;\n        this.maxIdleClients = maxIdleClients;\n        this.clientFactory = clientFactory;\n        this.clientDestructor = clientDestructor;\n        this.grpcEnabled = false;\n        /**\n         * Stores each active clients and how many operations it has outstanding.\n         */\n        this.activeClients = new Map();\n        /**\n         * A set of clients that have seen RST_STREAM errors (see\n         * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\n         * no longer be used.\n         */\n        this.failedClients = new Set();\n        /**\n         * A mapping from \"client\" objects to their corresponding IDs. These IDs have\n         * no semantic meaning but are used for logging to enable tracing the events\n         * of a particular client over time (such as creating, acquiring, and\n         * releasing).\n         */\n        this.clientIdByClient = new WeakMap();\n        /**\n         * Whether the Firestore instance has been terminated. Once terminated, the\n         * ClientPool can longer schedule new operations.\n         */\n        this.terminated = false;\n        /**\n         * Deferred promise that is resolved when there are no active operations on\n         * the client pool after terminate() has been called.\n         */\n        this.terminateDeferred = new util_1.Deferred();\n        /**\n         * A unique identifier for this object, for inclusion in log messages.\n         */\n        this.instanceId = 'cpl' + (0, util_1.requestTag)();\n        this.lazyLogStringForAllClientIds = new LazyLogStringForAllClientIds({\n            activeClients: this.activeClients,\n            failedClients: this.failedClients,\n            clientIdByClient: this.clientIdByClient,\n        });\n    }\n    /**\n     * Returns an already existing client if it has less than the maximum number\n     * of concurrent operations or initializes and returns a new client.\n     *\n     * @private\n     * @internal\n     */\n    acquire(requestTag, requiresGrpc) {\n        let selectedClient = null;\n        let selectedClientRequestCount = -1;\n        // Transition to grpc when we see the first operation that requires grpc.\n        this.grpcEnabled = this.grpcEnabled || requiresGrpc;\n        // Require a grpc client for this operation if we have transitioned to grpc.\n        requiresGrpc = requiresGrpc || this.grpcEnabled;\n        for (const [client, metadata] of this.activeClients) {\n            // Use the \"most-full\" client that can still accommodate the request\n            // in order to maximize the number of idle clients as operations start to\n            // complete.\n            if (!this.failedClients.has(client) &&\n                metadata.activeRequestCount > selectedClientRequestCount &&\n                metadata.activeRequestCount < this.concurrentOperationLimit &&\n                (metadata.grpcEnabled || !requiresGrpc)) {\n                selectedClient = client;\n                selectedClientRequestCount = metadata.activeRequestCount;\n            }\n        }\n        if (selectedClient) {\n            const selectedClientId = this.clientIdByClient.get(selectedClient);\n            (0, logger_1.logger)(`ClientPool[${this.instanceId}].acquire`, requestTag, 'Re-using existing client [%s] with %s remaining operations', selectedClientId, this.concurrentOperationLimit - selectedClientRequestCount);\n        }\n        else {\n            const newClientId = 'cli' + (0, util_1.requestTag)();\n            (0, logger_1.logger)(`ClientPool[${this.instanceId}].acquire`, requestTag, 'Creating a new client [%s] (requiresGrpc: %s)', newClientId, requiresGrpc);\n            selectedClient = this.clientFactory(requiresGrpc);\n            this.clientIdByClient.set(selectedClient, newClientId);\n            selectedClientRequestCount = 0;\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n        }\n        this.activeClients.set(selectedClient, {\n            grpcEnabled: requiresGrpc,\n            activeRequestCount: selectedClientRequestCount + 1,\n        });\n        return selectedClient;\n    }\n    /**\n     * Reduces the number of operations for the provided client, potentially\n     * removing it from the pool of active clients.\n     * @private\n     * @internal\n     */\n    async release(requestTag, client) {\n        const clientId = this.clientIdByClient.get(client);\n        const metadata = this.activeClients.get(client);\n        assert(metadata && metadata.activeRequestCount > 0, 'No active requests');\n        this.activeClients.set(client, {\n            grpcEnabled: metadata.grpcEnabled,\n            activeRequestCount: metadata.activeRequestCount - 1,\n        });\n        if (this.terminated && this.opCount === 0) {\n            this.terminateDeferred.resolve();\n        }\n        const gcDetermination = this.shouldGarbageCollectClient(client);\n        (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Releasing client [%s] (gc=%s)', clientId, gcDetermination);\n        if (!gcDetermination.shouldGarbageCollectClient) {\n            return;\n        }\n        (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Garbage collecting client [%s] (%s)', clientId, this.lazyLogStringForAllClientIds);\n        const activeClientDeleted = this.activeClients.delete(client);\n        this.failedClients.delete(client);\n        await this.clientDestructor(client);\n        (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Garbage collected client [%s] activeClientDeleted=%s (%s)', clientId, activeClientDeleted, this.lazyLogStringForAllClientIds);\n    }\n    /**\n     * Given the current operation counts, determines if the given client should\n     * be garbage collected.\n     * @private\n     * @internal\n     */\n    shouldGarbageCollectClient(client) {\n        const clientMetadata = this.activeClients.get(client);\n        if (clientMetadata.activeRequestCount !== 0) {\n            // Don't garbage collect clients that have active requests.\n            return new ClientHasActiveRequests({\n                shouldGarbageCollectClient: false,\n                clientActiveRequestCount: clientMetadata.activeRequestCount,\n            });\n        }\n        if (this.grpcEnabled !== clientMetadata.grpcEnabled) {\n            // We are transitioning to GRPC. Garbage collect REST clients.\n            return new PoolIsTransitioningToGrpc({\n                shouldGarbageCollectClient: true,\n                clientActiveRequestCount: clientMetadata.activeRequestCount,\n                poolGrpcEnabled: this.grpcEnabled,\n                clientGrpcEnabled: clientMetadata.grpcEnabled,\n            });\n        }\n        // Idle clients that have received RST_STREAM errors are always garbage\n        // collected.\n        if (this.failedClients.has(client)) {\n            return new ClientIsFailed({\n                shouldGarbageCollectClient: true,\n                clientActiveRequestCount: clientMetadata.activeRequestCount,\n            });\n        }\n        // Otherwise, only garbage collect if we have too much idle capacity (e.g.\n        // more than 100 idle capacity with default settings).\n        let idleCapacityCount = 0;\n        for (const [, metadata] of this.activeClients) {\n            idleCapacityCount +=\n                this.concurrentOperationLimit - metadata.activeRequestCount;\n        }\n        const maxIdleCapacityCount = this.maxIdleClients * this.concurrentOperationLimit;\n        return new IdleCapacity({\n            shouldGarbageCollectClient: idleCapacityCount > maxIdleCapacityCount,\n            clientActiveRequestCount: clientMetadata.activeRequestCount,\n            idleCapacityCount: idleCapacityCount,\n            maxIdleCapacityCount: maxIdleCapacityCount,\n            maxIdleClients: this.maxIdleClients,\n            concurrentOperationLimit: this.concurrentOperationLimit,\n        });\n    }\n    /**\n     * The number of currently registered clients.\n     *\n     * @return Number of currently registered clients.\n     * @private\n     * @internal\n     */\n    // Visible for testing.\n    get size() {\n        return this.activeClients.size;\n    }\n    /**\n     * The number of currently active operations.\n     *\n     * @return Number of currently active operations.\n     * @private\n     * @internal\n     */\n    // Visible for testing.\n    get opCount() {\n        let activeOperationCount = 0;\n        this.activeClients.forEach(metadata => (activeOperationCount += metadata.activeRequestCount));\n        return activeOperationCount;\n    }\n    /**\n     * The currently active clients.\n     *\n     * @return The currently active clients.\n     * @private\n     * @internal\n     */\n    // Visible for testing.\n    get _activeClients() {\n        return this.activeClients;\n    }\n    /**\n     * Runs the provided operation in this pool. This function may create an\n     * additional client if all existing clients already operate at the concurrent\n     * operation limit.\n     *\n     * @param requestTag A unique client-assigned identifier for this operation.\n     * @param op A callback function that returns a Promise. The client T will\n     * be returned to the pool when callback finishes.\n     * @return A Promise that resolves with the result of `op`.\n     * @private\n     * @internal\n     */\n    run(requestTag, requiresGrpc, op) {\n        if (this.terminated) {\n            return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\n        }\n        const client = this.acquire(requestTag, requiresGrpc);\n        return op(client)\n            .catch(async (err) => {\n            var _a;\n            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\n                // Once a client has seen a RST_STREAM error, the GRPC channel can\n                // no longer be used. We mark the client as failed, which ensures that\n                // we open a new GRPC channel for the next request.\n                this.failedClients.add(client);\n            }\n            await this.release(requestTag, client);\n            return Promise.reject(err);\n        })\n            .then(async (res) => {\n            await this.release(requestTag, client);\n            return res;\n        });\n    }\n    async terminate() {\n        this.terminated = true;\n        // Wait for all pending operations to complete before terminating.\n        if (this.opCount > 0) {\n            (0, logger_1.logger)(`ClientPool[${this.instanceId}].terminate`, \n            /* requestTag= */ null, 'Waiting for %s pending operations to complete before terminating (%s)', this.opCount, this.lazyLogStringForAllClientIds);\n            await this.terminateDeferred.promise;\n        }\n        (0, logger_1.logger)(`ClientPool[${this.instanceId}].terminate`, \n        /* requestTag= */ null, 'Closing all active clients (%s)', this.lazyLogStringForAllClientIds);\n        for (const [client] of this.activeClients) {\n            this.activeClients.delete(client);\n            await this.clientDestructor(client);\n        }\n    }\n}\nexports.ClientPool = ClientPool;\n/**\n * Helper class that, when logged as a direct argument of `logger()`, will\n * lazily evaluate to a long string that contains all IDs of both active and\n * failed clients.\n */\nclass LazyLogStringForAllClientIds {\n    constructor(config) {\n        this.activeClients = config.activeClients;\n        this.failedClients = config.failedClients;\n        this.clientIdByClient = config.clientIdByClient;\n    }\n    toString() {\n        const activeClientsDescription = Array.from(this.activeClients.entries())\n            .map(([client, metadata]) => `${this.clientIdByClient.get(client)}=${metadata.activeRequestCount}`)\n            .sort()\n            .join(', ');\n        const failedClientsDescription = Array.from(this.failedClients)\n            .map(client => `${this.clientIdByClient.get(client)}`)\n            .sort()\n            .join(', ');\n        return (`${this.activeClients.size} active clients: {` +\n            activeClientsDescription +\n            '}, ' +\n            `${this.failedClients.size} failed clients: {` +\n            failedClientsDescription +\n            '}');\n    }\n}\n/**\n * Minimum data to be included in the objects returned from\n * ClientPool.shouldGarbageCollectClient().\n */\nclass BaseShouldGarbageCollectClientResult {\n    /**\n     * Return a terse, one-line string representation. This makes it easy to\n     * grep through log output to find the logged values.\n     */\n    toString() {\n        const propertyStrings = [];\n        for (const propertyName of Object.getOwnPropertyNames(this)) {\n            const propertyValue = this[propertyName];\n            propertyStrings.push(`${propertyName}=${propertyValue}`);\n        }\n        return '{' + propertyStrings.join(', ') + '}';\n    }\n}\nclass ClientHasActiveRequests extends BaseShouldGarbageCollectClientResult {\n    constructor(args) {\n        super();\n        this.name = 'ClientHasActiveRequests';\n        this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;\n        this.clientActiveRequestCount = args.clientActiveRequestCount;\n    }\n}\nclass PoolIsTransitioningToGrpc extends BaseShouldGarbageCollectClientResult {\n    constructor(args) {\n        super();\n        this.name = 'PoolIsTransitioningToGrpc';\n        this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;\n        this.clientActiveRequestCount = args.clientActiveRequestCount;\n        this.poolGrpcEnabled = args.poolGrpcEnabled;\n        this.clientGrpcEnabled = args.clientGrpcEnabled;\n    }\n}\nclass ClientIsFailed extends BaseShouldGarbageCollectClientResult {\n    constructor(args) {\n        super();\n        this.name = 'ClientIsFailed';\n        this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;\n        this.clientActiveRequestCount = args.clientActiveRequestCount;\n    }\n}\nclass IdleCapacity extends BaseShouldGarbageCollectClientResult {\n    constructor(args) {\n        super();\n        this.name = 'IdleCapacity';\n        this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;\n        this.clientActiveRequestCount = args.clientActiveRequestCount;\n        this.idleCapacityCount = args.idleCapacityCount;\n        this.maxIdleCapacityCount = args.maxIdleCapacityCount;\n        this.maxIdleClients = args.maxIdleClients;\n        this.concurrentOperationLimit = args.concurrentOperationLimit;\n    }\n}\n//# sourceMappingURL=pool.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}