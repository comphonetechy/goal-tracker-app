{"ast":null,"code":"/*! firebase-admin v13.6.1 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FIREBASE_CONFIG_VAR = exports.defaultAppStore = exports.AppStore = void 0;\nexports.initializeApp = initializeApp;\nexports.getApp = getApp;\nexports.getApps = getApps;\nexports.deleteApp = deleteApp;\nconst fs = require(\"fs\");\nconst validator = require(\"../utils/validator\");\nconst error_1 = require(\"../utils/error\");\nconst credential_internal_1 = require(\"./credential-internal\");\nconst firebase_app_1 = require(\"./firebase-app\");\nconst fastDeepEqual = require('fast-deep-equal');\nconst DEFAULT_APP_NAME = '[DEFAULT]';\nclass AppStore {\n  constructor() {\n    this.appStore = new Map();\n  }\n  initializeApp(options, appName = DEFAULT_APP_NAME) {\n    validateAppNameFormat(appName);\n    let autoInit = false;\n    if (typeof options === 'undefined') {\n      autoInit = true;\n      options = loadOptionsFromEnvVar();\n      options.credential = (0, credential_internal_1.getApplicationDefault)();\n    }\n    // Check if an app already exists and, if so, ensure its `AppOptions` match\n    // those of this `initializeApp` request. \n    if (!this.appStore.has(appName)) {\n      const app = new firebase_app_1.FirebaseApp(options, appName, autoInit, this);\n      this.appStore.set(app.name, app);\n      return app;\n    }\n    const currentApp = this.appStore.get(appName);\n    // Ensure the `autoInit` state matches the existing app's. If not, throw.\n    if (currentApp.autoInit() !== autoInit) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `A Firebase app named \"${appName}\" already exists with a different configuration.`);\n    }\n    if (autoInit) {\n      // Auto-initialization is triggered when no options were passed to\n      // `initializeApp`. With no options to compare, simply return the App.\n      return currentApp;\n    }\n    // Ensure the options objects don't break deep equal comparisons.\n    validateAppOptionsSupportDeepEquals(options, currentApp);\n    // `FirebaseApp()` adds a synthesized `Credential` to `app.options` upon\n    // app construction. Run a comparison w/o `Credential` to see if the base\n    // configurations match. Return the existing app if so.\n    const currentAppOptions = {\n      ...currentApp.options\n    };\n    delete currentAppOptions.credential;\n    if (!fastDeepEqual(options, currentAppOptions)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `A Firebase app named \"${appName}\" already exists with a different configuration.`);\n    }\n    return currentApp;\n  }\n  getApp(appName = DEFAULT_APP_NAME) {\n    validateAppNameFormat(appName);\n    if (!this.appStore.has(appName)) {\n      let errorMessage = appName === DEFAULT_APP_NAME ? 'The default Firebase app does not exist. ' : `Firebase app named \"${appName}\" does not exist. `;\n      errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);\n    }\n    return this.appStore.get(appName);\n  }\n  getApps() {\n    // Return a copy so the caller cannot mutate the array\n    return Array.from(this.appStore.values());\n  }\n  deleteApp(app) {\n    if (typeof app !== 'object' || app === null || !('options' in app)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'Invalid app argument.');\n    }\n    // Make sure the given app already exists.\n    const existingApp = getApp(app.name);\n    // Delegate delete operation to the App instance itself. That will also remove the App\n    // instance from the AppStore.\n    return existingApp.delete();\n  }\n  clearAllApps() {\n    const promises = [];\n    this.getApps().forEach(app => {\n      promises.push(this.deleteApp(app));\n    });\n    return Promise.all(promises).then();\n  }\n  /**\n   * Removes the specified App instance from the store. This is currently called by the\n   * {@link FirebaseApp.delete} method. Can be removed once the app deletion is handled\n   * entirely by the {@link deleteApp} top-level function.\n   */\n  removeApp(appName) {\n    this.appStore.delete(appName);\n  }\n}\nexports.AppStore = AppStore;\n/**\n * Validates that the `requestedOptions` and the `existingApp` options objects\n * do not have fields that would break deep equals comparisons.\n *\n * @param requestedOptions The incoming `AppOptions` of a new `initailizeApp`\n *   request.\n * @param existingApp An existing `FirebaseApp` with internal `options` to\n *   compare against.\n *\n * @throws FirebaseAppError if the objects cannot be deeply compared.\n *\n * @internal\n */\nfunction validateAppOptionsSupportDeepEquals(requestedOptions, existingApp) {\n  // http.Agent checks.\n  if (typeof requestedOptions.httpAgent !== 'undefined') {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Firebase app named \"${existingApp.name}\" already exists and initializeApp was` + ' invoked with an optional http.Agent. The SDK cannot confirm the equality' + ' of http.Agent objects with the existing app. Please use getApp or getApps to reuse' + ' the existing app instead.');\n  } else if (typeof existingApp.options.httpAgent !== 'undefined') {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `An existing app named \"${existingApp.name}\" already exists with a different` + ' options configuration: httpAgent.');\n  }\n  // Credential checks.\n  if (typeof requestedOptions.credential !== 'undefined') {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Firebase app named \"${existingApp.name}\" already exists and initializeApp was` + ' invoked with an optional Credential. The SDK cannot confirm the equality' + ' of Credential objects with the existing app. Please use getApp or getApps' + ' to reuse the existing app instead.');\n  }\n  if (existingApp.customCredential()) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `An existing app named \"${existingApp.name}\" already exists with a different` + ' options configuration: Credential.');\n  }\n}\n/**\n * Checks to see if the provided appName is a non-empty string and throws if it\n * is not.\n *\n * @param appName A string representation of an App name.\n *\n * @throws FirebaseAppError if appName is not of type string or is empty.\n *\n * @internal\n */\nfunction validateAppNameFormat(appName) {\n  if (!validator.isNonEmptyString(appName)) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name \"${appName}\" provided. App name must be a non-empty string.`);\n  }\n}\nexports.defaultAppStore = new AppStore();\n/**\n * Initializes the `App` instance.\n *\n * Creates a new instance of {@link App} if one doesn't exist, or returns an existing\n * `App` instance if one exists with the same `appName` and `options`.\n *\n * Note, due to the inablity to compare `http.Agent` objects and `Credential` objects,\n * this function cannot support idempotency if either of `options.httpAgent` or\n * `options.credential` are defined. When either is defined, subsequent invocations will\n * throw a `FirebaseAppError` instead of returning an `App` object.\n *\n * For example, to safely initialize an app that may already exist:\n *\n * ```javascript\n * let app;\n * try {\n *   app = getApp(\"myApp\");\n * } catch (error) {\n *   app = initializeApp({ credential: myCredential }, \"myApp\");\n * }\n * ```\n *\n * @param options - Optional A set of {@link AppOptions} for the `App` instance.\n *   If not present, `initializeApp` will try to initialize with the options from the\n *   `FIREBASE_CONFIG` environment variable. If the environment variable contains a\n *   string that starts with `{` it will be parsed as JSON, otherwise it will be\n *   assumed to be pointing to a file.\n * @param appName - Optional name of the `App` instance.\n *\n * @returns A new App instance, or the existing App if the instance already exists with\n *   the provided configuration.\n *\n * @throws FirebaseAppError if an `App` with the same name has already been\n *   initialized with a different set of `AppOptions`.\n * @throws FirebaseAppError if an existing `App` exists and `options.httpAgent`\n *   or `options.credential` are defined. This is due to the function's inability to\n *   determine if the existing `App`'s `options` equate to the `options` parameter\n *   of this function. It's recommended to use {@link getApp} or {@link getApps} if your\n *   implementation uses either of these two fields in `AppOptions`.\n */\nfunction initializeApp(options, appName = DEFAULT_APP_NAME) {\n  return exports.defaultAppStore.initializeApp(options, appName);\n}\n/**\n * Returns an existing {@link App} instance for the provided name. If no name\n * is provided the the default app name is used.\n *\n * @param appName - Optional name of the `App` instance.\n *\n * @returns An existing `App` instance that matches the name provided.\n *\n * @throws FirebaseAppError if no `App` exists for the given name.\n * @throws FirebaseAppError if the `appName` is malformed.\n */\nfunction getApp(appName = DEFAULT_APP_NAME) {\n  return exports.defaultAppStore.getApp(appName);\n}\n/**\n * A (read-only) array of all initialized apps.\n *\n * @returns An array containing all initialized apps.\n */\nfunction getApps() {\n  return exports.defaultAppStore.getApps();\n}\n/**\n * Renders this given `App` unusable and frees the resources of\n * all associated services (though it does *not* clean up any backend\n * resources). When running the SDK locally, this method\n * must be called to ensure graceful termination of the process.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n */\nfunction deleteApp(app) {\n  return exports.defaultAppStore.deleteApp(app);\n}\n/**\n * Constant holding the environment variable name with the default config.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nexports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';\n/**\n * Parse the file pointed to by the FIREBASE_CONFIG_VAR, if it exists.\n * Or if the FIREBASE_CONFIG_ENV contains a valid JSON object, parse it directly.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nfunction loadOptionsFromEnvVar() {\n  const config = process.env[exports.FIREBASE_CONFIG_VAR];\n  if (!validator.isNonEmptyString(config)) {\n    return {};\n  }\n  try {\n    const contents = config.startsWith('{') ? config : fs.readFileSync(config, 'utf8');\n    return JSON.parse(contents);\n  } catch (error) {\n    // Throw a nicely formed error message if the file contents cannot be parsed\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","FIREBASE_CONFIG_VAR","defaultAppStore","AppStore","initializeApp","getApp","getApps","deleteApp","fs","require","validator","error_1","credential_internal_1","firebase_app_1","fastDeepEqual","DEFAULT_APP_NAME","constructor","appStore","Map","options","appName","validateAppNameFormat","autoInit","loadOptionsFromEnvVar","credential","getApplicationDefault","has","app","FirebaseApp","set","name","currentApp","get","FirebaseAppError","AppErrorCodes","INVALID_APP_OPTIONS","validateAppOptionsSupportDeepEquals","currentAppOptions","DUPLICATE_APP","errorMessage","NO_APP","Array","from","values","INVALID_ARGUMENT","existingApp","delete","clearAllApps","promises","forEach","push","Promise","all","then","removeApp","requestedOptions","httpAgent","customCredential","isNonEmptyString","INVALID_APP_NAME","config","process","env","contents","startsWith","readFileSync","JSON","parse","error"],"sources":["C:/Users/PROGRAMMER/Desktop/goal tracker app clone/goal-tracker-app/client/node_modules/firebase-admin/lib/app/lifecycle.js"],"sourcesContent":["/*! firebase-admin v13.6.1 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FIREBASE_CONFIG_VAR = exports.defaultAppStore = exports.AppStore = void 0;\nexports.initializeApp = initializeApp;\nexports.getApp = getApp;\nexports.getApps = getApps;\nexports.deleteApp = deleteApp;\nconst fs = require(\"fs\");\nconst validator = require(\"../utils/validator\");\nconst error_1 = require(\"../utils/error\");\nconst credential_internal_1 = require(\"./credential-internal\");\nconst firebase_app_1 = require(\"./firebase-app\");\nconst fastDeepEqual = require('fast-deep-equal');\nconst DEFAULT_APP_NAME = '[DEFAULT]';\nclass AppStore {\n    constructor() {\n        this.appStore = new Map();\n    }\n    initializeApp(options, appName = DEFAULT_APP_NAME) {\n        validateAppNameFormat(appName);\n        let autoInit = false;\n        if (typeof options === 'undefined') {\n            autoInit = true;\n            options = loadOptionsFromEnvVar();\n            options.credential = (0, credential_internal_1.getApplicationDefault)();\n        }\n        // Check if an app already exists and, if so, ensure its `AppOptions` match\n        // those of this `initializeApp` request. \n        if (!this.appStore.has(appName)) {\n            const app = new firebase_app_1.FirebaseApp(options, appName, autoInit, this);\n            this.appStore.set(app.name, app);\n            return app;\n        }\n        const currentApp = this.appStore.get(appName);\n        // Ensure the `autoInit` state matches the existing app's. If not, throw.\n        if (currentApp.autoInit() !== autoInit) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `A Firebase app named \"${appName}\" already exists with a different configuration.`);\n        }\n        if (autoInit) {\n            // Auto-initialization is triggered when no options were passed to\n            // `initializeApp`. With no options to compare, simply return the App.\n            return currentApp;\n        }\n        // Ensure the options objects don't break deep equal comparisons.\n        validateAppOptionsSupportDeepEquals(options, currentApp);\n        // `FirebaseApp()` adds a synthesized `Credential` to `app.options` upon\n        // app construction. Run a comparison w/o `Credential` to see if the base\n        // configurations match. Return the existing app if so.\n        const currentAppOptions = { ...currentApp.options };\n        delete currentAppOptions.credential;\n        if (!fastDeepEqual(options, currentAppOptions)) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `A Firebase app named \"${appName}\" already exists with a different configuration.`);\n        }\n        return currentApp;\n    }\n    getApp(appName = DEFAULT_APP_NAME) {\n        validateAppNameFormat(appName);\n        if (!this.appStore.has(appName)) {\n            let errorMessage = (appName === DEFAULT_APP_NAME)\n                ? 'The default Firebase app does not exist. ' : `Firebase app named \"${appName}\" does not exist. `;\n            errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);\n        }\n        return this.appStore.get(appName);\n    }\n    getApps() {\n        // Return a copy so the caller cannot mutate the array\n        return Array.from(this.appStore.values());\n    }\n    deleteApp(app) {\n        if (typeof app !== 'object' || app === null || !('options' in app)) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'Invalid app argument.');\n        }\n        // Make sure the given app already exists.\n        const existingApp = getApp(app.name);\n        // Delegate delete operation to the App instance itself. That will also remove the App\n        // instance from the AppStore.\n        return existingApp.delete();\n    }\n    clearAllApps() {\n        const promises = [];\n        this.getApps().forEach((app) => {\n            promises.push(this.deleteApp(app));\n        });\n        return Promise.all(promises).then();\n    }\n    /**\n     * Removes the specified App instance from the store. This is currently called by the\n     * {@link FirebaseApp.delete} method. Can be removed once the app deletion is handled\n     * entirely by the {@link deleteApp} top-level function.\n     */\n    removeApp(appName) {\n        this.appStore.delete(appName);\n    }\n}\nexports.AppStore = AppStore;\n/**\n * Validates that the `requestedOptions` and the `existingApp` options objects\n * do not have fields that would break deep equals comparisons.\n *\n * @param requestedOptions The incoming `AppOptions` of a new `initailizeApp`\n *   request.\n * @param existingApp An existing `FirebaseApp` with internal `options` to\n *   compare against.\n *\n * @throws FirebaseAppError if the objects cannot be deeply compared.\n *\n * @internal\n */\nfunction validateAppOptionsSupportDeepEquals(requestedOptions, existingApp) {\n    // http.Agent checks.\n    if (typeof requestedOptions.httpAgent !== 'undefined') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Firebase app named \"${existingApp.name}\" already exists and initializeApp was` +\n            ' invoked with an optional http.Agent. The SDK cannot confirm the equality' +\n            ' of http.Agent objects with the existing app. Please use getApp or getApps to reuse' +\n            ' the existing app instead.');\n    }\n    else if (typeof existingApp.options.httpAgent !== 'undefined') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `An existing app named \"${existingApp.name}\" already exists with a different` +\n            ' options configuration: httpAgent.');\n    }\n    // Credential checks.\n    if (typeof requestedOptions.credential !== 'undefined') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Firebase app named \"${existingApp.name}\" already exists and initializeApp was` +\n            ' invoked with an optional Credential. The SDK cannot confirm the equality' +\n            ' of Credential objects with the existing app. Please use getApp or getApps' +\n            ' to reuse the existing app instead.');\n    }\n    if (existingApp.customCredential()) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `An existing app named \"${existingApp.name}\" already exists with a different` +\n            ' options configuration: Credential.');\n    }\n}\n/**\n * Checks to see if the provided appName is a non-empty string and throws if it\n * is not.\n *\n * @param appName A string representation of an App name.\n *\n * @throws FirebaseAppError if appName is not of type string or is empty.\n *\n * @internal\n */\nfunction validateAppNameFormat(appName) {\n    if (!validator.isNonEmptyString(appName)) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name \"${appName}\" provided. App name must be a non-empty string.`);\n    }\n}\nexports.defaultAppStore = new AppStore();\n/**\n * Initializes the `App` instance.\n *\n * Creates a new instance of {@link App} if one doesn't exist, or returns an existing\n * `App` instance if one exists with the same `appName` and `options`.\n *\n * Note, due to the inablity to compare `http.Agent` objects and `Credential` objects,\n * this function cannot support idempotency if either of `options.httpAgent` or\n * `options.credential` are defined. When either is defined, subsequent invocations will\n * throw a `FirebaseAppError` instead of returning an `App` object.\n *\n * For example, to safely initialize an app that may already exist:\n *\n * ```javascript\n * let app;\n * try {\n *   app = getApp(\"myApp\");\n * } catch (error) {\n *   app = initializeApp({ credential: myCredential }, \"myApp\");\n * }\n * ```\n *\n * @param options - Optional A set of {@link AppOptions} for the `App` instance.\n *   If not present, `initializeApp` will try to initialize with the options from the\n *   `FIREBASE_CONFIG` environment variable. If the environment variable contains a\n *   string that starts with `{` it will be parsed as JSON, otherwise it will be\n *   assumed to be pointing to a file.\n * @param appName - Optional name of the `App` instance.\n *\n * @returns A new App instance, or the existing App if the instance already exists with\n *   the provided configuration.\n *\n * @throws FirebaseAppError if an `App` with the same name has already been\n *   initialized with a different set of `AppOptions`.\n * @throws FirebaseAppError if an existing `App` exists and `options.httpAgent`\n *   or `options.credential` are defined. This is due to the function's inability to\n *   determine if the existing `App`'s `options` equate to the `options` parameter\n *   of this function. It's recommended to use {@link getApp} or {@link getApps} if your\n *   implementation uses either of these two fields in `AppOptions`.\n */\nfunction initializeApp(options, appName = DEFAULT_APP_NAME) {\n    return exports.defaultAppStore.initializeApp(options, appName);\n}\n/**\n * Returns an existing {@link App} instance for the provided name. If no name\n * is provided the the default app name is used.\n *\n * @param appName - Optional name of the `App` instance.\n *\n * @returns An existing `App` instance that matches the name provided.\n *\n * @throws FirebaseAppError if no `App` exists for the given name.\n * @throws FirebaseAppError if the `appName` is malformed.\n */\nfunction getApp(appName = DEFAULT_APP_NAME) {\n    return exports.defaultAppStore.getApp(appName);\n}\n/**\n * A (read-only) array of all initialized apps.\n *\n * @returns An array containing all initialized apps.\n */\nfunction getApps() {\n    return exports.defaultAppStore.getApps();\n}\n/**\n * Renders this given `App` unusable and frees the resources of\n * all associated services (though it does *not* clean up any backend\n * resources). When running the SDK locally, this method\n * must be called to ensure graceful termination of the process.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n */\nfunction deleteApp(app) {\n    return exports.defaultAppStore.deleteApp(app);\n}\n/**\n * Constant holding the environment variable name with the default config.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nexports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';\n/**\n * Parse the file pointed to by the FIREBASE_CONFIG_VAR, if it exists.\n * Or if the FIREBASE_CONFIG_ENV contains a valid JSON object, parse it directly.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nfunction loadOptionsFromEnvVar() {\n    const config = process.env[exports.FIREBASE_CONFIG_VAR];\n    if (!validator.isNonEmptyString(config)) {\n        return {};\n    }\n    try {\n        const contents = config.startsWith('{') ? config : fs.readFileSync(config, 'utf8');\n        return JSON.parse(contents);\n    }\n    catch (error) {\n        // Throw a nicely formed error message if the file contents cannot be parsed\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}