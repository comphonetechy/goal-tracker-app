{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryUtil = void 0;\nconst stream_1 = require(\"stream\");\nconst timestamp_1 = require(\"../timestamp\");\nconst document_1 = require(\"../document\");\nconst util_1 = require(\"../util\");\nconst document_change_1 = require(\"../document-change\");\nconst query_profile_1 = require(\"../query-profile\");\nconst logger_1 = require(\"../logger\");\nconst vector_query_1 = require(\"./vector-query\");\nconst types_1 = require(\"./types\");\nconst constants_1 = require(\"./constants\");\nconst trace_util_1 = require(\"../telemetry/trace-util\");\nclass QueryUtil {\n  constructor(/** @private */\n  _firestore, /** @private */\n  _queryOptions, /** @private */\n  _serializer) {\n    this._firestore = _firestore;\n    this._queryOptions = _queryOptions;\n    this._serializer = _serializer;\n  }\n  _getResponse(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack;\n    return new Promise((resolve, reject) => {\n      const docs = [];\n      const output = {};\n      this._stream(query, transactionOrReadTime, retryWithCursor, explainOptions).on('error', err => {\n        reject((0, util_1.wrapError)(err, stack));\n      }).on('data', data => {\n        if (data.transaction) {\n          output.transaction = data.transaction;\n        }\n        if (data.readTime) {\n          output.readTime = data.readTime;\n        }\n        if (data.explainMetrics) {\n          output.explainMetrics = data.explainMetrics;\n        }\n        if (data.document) {\n          docs.push(data.document);\n        }\n      }).on('end', () => {\n        if (this._queryOptions.limitType === types_1.LimitType.Last) {\n          // The results for limitToLast queries need to be flipped since\n          // we reversed the ordering constraints before sending the query\n          // to the backend.\n          docs.reverse();\n        }\n        // Only return a snapshot when we have a readTime\n        // explain queries with analyze !== true will return no documents and no read time\n        const result = output.readTime ? query._createSnapshot(output.readTime, docs.length, () => docs, () => {\n          const changes = [];\n          for (let i = 0; i < docs.length; ++i) {\n            changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n          }\n          return changes;\n        }) : undefined;\n        resolve({\n          transaction: output.transaction,\n          explainMetrics: output.explainMetrics,\n          result\n        });\n      });\n    });\n  }\n  // This method exists solely to enable unit tests to mock it.\n  _isPermanentRpcError(err, methodName) {\n    return (0, util_1.isPermanentRpcError)(err, methodName);\n  }\n  _hasRetryTimedOut(methodName, startTime) {\n    const totalTimeout = (0, util_1.getTotalTimeout)(methodName);\n    if (totalTimeout === 0) {\n      return false;\n    }\n    return Date.now() - startTime >= totalTimeout;\n  }\n  stream(query) {\n    if (this._queryOptions.limitType === types_1.LimitType.Last) {\n      throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.get() instead.');\n    }\n    const responseStream = this._stream(query);\n    const transform = new stream_1.Transform({\n      objectMode: true,\n      transform(chunk, encoding, callback) {\n        callback(undefined, chunk.document);\n      }\n    });\n    responseStream.pipe(transform);\n    responseStream.on('error', e => transform.destroy(e));\n    return transform;\n  }\n  _stream(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {\n    const tag = (0, util_1.requestTag)();\n    const startTime = Date.now();\n    const isExplain = explainOptions !== undefined;\n    const methodName = 'runQuery';\n    let numDocumentsReceived = 0;\n    let lastReceivedDocument = null;\n    let backendStream;\n    const stream = new stream_1.Transform({\n      objectMode: true,\n      transform: (proto, enc, callback) => {\n        var _a;\n        if (proto === constants_1.NOOP_MESSAGE) {\n          callback(undefined);\n          return;\n        }\n        const output = {};\n        // Proto comes with zero-length buffer by default\n        if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n          output.transaction = proto.transaction;\n        }\n        if (proto.readTime) {\n          output.readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n        }\n        if (proto.document) {\n          const document = this._firestore.snapshot_(proto.document, proto.readTime);\n          const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));\n          // Recreate the QueryDocumentSnapshot with the DocumentReference\n          // containing the original converter.\n          finalDoc.fieldsProto = document._fieldsProto;\n          finalDoc.readTime = document.readTime;\n          finalDoc.createTime = document.createTime;\n          finalDoc.updateTime = document.updateTime;\n          lastReceivedDocument = finalDoc.build();\n          output.document = lastReceivedDocument;\n        }\n        if (proto.explainMetrics) {\n          output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, this._serializer);\n        }\n        ++numDocumentsReceived;\n        callback(undefined, output);\n        if (proto.done) {\n          (0, logger_1.logger)('QueryUtil._stream', tag, 'Trigger Logical Termination.');\n          this._firestore._traceUtil.currentSpan().addEvent(`Firestore.${methodName}: Received RunQueryResponse.Done.`);\n          backendStream.unpipe(stream);\n          backendStream.resume();\n          backendStream.end();\n          stream.end();\n        }\n      }\n    });\n    this._firestore.initializeIfNeeded(tag).then(async () => {\n      // `toProto()` might throw an exception. We rely on the behavior of an\n      // async function to convert this exception into the rejected Promise we\n      // catch below.\n      let request = query.toProto(transactionOrReadTime, explainOptions);\n      let isRetryRequestWithCursor = false;\n      let streamActive;\n      do {\n        streamActive = new util_1.Deferred();\n        this._firestore._traceUtil.currentSpan().addEvent(trace_util_1.SPAN_NAME_RUN_QUERY, {\n          [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: !!request.transaction,\n          [trace_util_1.ATTRIBUTE_KEY_IS_RETRY_WITH_CURSOR]: isRetryRequestWithCursor\n        });\n        backendStream = await this._firestore.requestStream(methodName, /* bidirectional= */false, request, tag);\n        backendStream.on('error', err => {\n          backendStream.unpipe(stream);\n          // If a non-transactional query failed, attempt to restart.\n          // Transactional queries are retried via the transaction runner.\n          // Explain queries are not retried with a cursor. That would produce\n          // incorrect/partial profiling results.\n          if (!isExplain && !transactionOrReadTime && !this._isPermanentRpcError(err, methodName)) {\n            (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error:', err);\n            this._firestore._traceUtil.currentSpan().addEvent(`${trace_util_1.SPAN_NAME_RUN_QUERY}: Retryable Error.`, {\n              'error.message': err.message\n            });\n            // Enqueue a \"no-op\" write into the stream and wait for it to be\n            // read by the downstream consumer. This ensures that all enqueued\n            // results in the stream are consumed, which will give us an accurate\n            // value for `lastReceivedDocument`.\n            stream.write(constants_1.NOOP_MESSAGE, () => {\n              if (this._hasRetryTimedOut(methodName, startTime)) {\n                (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error but the total retry timeout has exceeded.');\n                stream.destroy(err);\n                streamActive.resolve(/* active= */false);\n              } else if (lastReceivedDocument && retryWithCursor) {\n                if (query instanceof vector_query_1.VectorQuery) {\n                  throw new Error('Unimplemented: Vector query does not support cursors yet.');\n                }\n                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error and progress was made receiving ' + 'documents, so the stream is being retried.');\n                isRetryRequestWithCursor = true;\n                // Restart the query but use the last document we received as\n                // the query cursor. Note that we do not use backoff here. The\n                // call to `requestStream()` will backoff should the restart\n                // fail before delivering any results.\n                let newQuery;\n                if (!this._queryOptions.limit) {\n                  newQuery = query;\n                } else {\n                  const newLimit = this._queryOptions.limit - numDocumentsReceived;\n                  if (this._queryOptions.limitType === undefined || this._queryOptions.limitType === types_1.LimitType.First) {\n                    newQuery = query.limit(newLimit);\n                  } else {\n                    newQuery = query.limitToLast(newLimit);\n                  }\n                }\n                if (this._queryOptions.requireConsistency) {\n                  request = newQuery.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);\n                } else {\n                  request = newQuery.startAfter(lastReceivedDocument).toProto();\n                }\n                // Set lastReceivedDocument to null before each retry attempt to ensure the retry makes progress\n                lastReceivedDocument = null;\n                streamActive.resolve(/* active= */true);\n              } else {\n                (0, logger_1.logger)('QueryUtil._stream', tag, `Query failed with retryable stream error however either retryWithCursor=\"${retryWithCursor}\", or ` + 'no progress was made receiving documents, so the stream is being closed.');\n                stream.destroy(err);\n                streamActive.resolve(/* active= */false);\n              }\n            });\n          } else {\n            (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with stream error:', err);\n            this._firestore._traceUtil.currentSpan().addEvent(`${trace_util_1.SPAN_NAME_RUN_QUERY}: Error.`, {\n              'error.message': err.message\n            });\n            stream.destroy(err);\n            streamActive.resolve(/* active= */false);\n          }\n        });\n        backendStream.on('end', () => {\n          streamActive.resolve(/* active= */false);\n        });\n        backendStream.resume();\n        backendStream.pipe(stream);\n      } while (await streamActive.promise);\n    }).catch(e => stream.destroy(e));\n    return stream;\n  }\n}\nexports.QueryUtil = QueryUtil;","map":{"version":3,"names":["Object","defineProperty","exports","value","QueryUtil","stream_1","require","timestamp_1","document_1","util_1","document_change_1","query_profile_1","logger_1","vector_query_1","types_1","constants_1","trace_util_1","constructor","_firestore","_queryOptions","_serializer","_getResponse","query","transactionOrReadTime","retryWithCursor","explainOptions","stack","Error","Promise","resolve","reject","docs","output","_stream","on","err","wrapError","data","transaction","readTime","explainMetrics","document","push","limitType","LimitType","Last","reverse","result","_createSnapshot","length","changes","i","DocumentChange","undefined","_isPermanentRpcError","methodName","isPermanentRpcError","_hasRetryTimedOut","startTime","totalTimeout","getTotalTimeout","Date","now","stream","responseStream","transform","Transform","objectMode","chunk","encoding","callback","pipe","e","destroy","tag","requestTag","isExplain","numDocumentsReceived","lastReceivedDocument","backendStream","proto","enc","_a","NOOP_MESSAGE","Timestamp","fromProto","snapshot_","finalDoc","DocumentSnapshotBuilder","ref","withConverter","converter","fieldsProto","_fieldsProto","createTime","updateTime","build","ExplainMetrics","_fromProto","done","logger","_traceUtil","currentSpan","addEvent","unpipe","resume","end","initializeIfNeeded","then","request","toProto","isRetryRequestWithCursor","streamActive","Deferred","SPAN_NAME_RUN_QUERY","ATTRIBUTE_KEY_IS_TRANSACTIONAL","ATTRIBUTE_KEY_IS_RETRY_WITH_CURSOR","requestStream","message","write","VectorQuery","newQuery","limit","newLimit","First","limitToLast","requireConsistency","startAfter","promise","catch"],"sources":["C:/Users/PROGRAMMER/Desktop/goal tracker app clone/goal-tracker-app/client/node_modules/@google-cloud/firestore/build/src/reference/query-util.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryUtil = void 0;\nconst stream_1 = require(\"stream\");\nconst timestamp_1 = require(\"../timestamp\");\nconst document_1 = require(\"../document\");\nconst util_1 = require(\"../util\");\nconst document_change_1 = require(\"../document-change\");\nconst query_profile_1 = require(\"../query-profile\");\nconst logger_1 = require(\"../logger\");\nconst vector_query_1 = require(\"./vector-query\");\nconst types_1 = require(\"./types\");\nconst constants_1 = require(\"./constants\");\nconst trace_util_1 = require(\"../telemetry/trace-util\");\nclass QueryUtil {\n    constructor(\n    /** @private */\n    _firestore, \n    /** @private */\n    _queryOptions, \n    /** @private */\n    _serializer) {\n        this._firestore = _firestore;\n        this._queryOptions = _queryOptions;\n        this._serializer = _serializer;\n    }\n    _getResponse(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return new Promise((resolve, reject) => {\n            const docs = [];\n            const output = {};\n            this._stream(query, transactionOrReadTime, retryWithCursor, explainOptions)\n                .on('error', err => {\n                reject((0, util_1.wrapError)(err, stack));\n            })\n                .on('data', (data) => {\n                if (data.transaction) {\n                    output.transaction = data.transaction;\n                }\n                if (data.readTime) {\n                    output.readTime = data.readTime;\n                }\n                if (data.explainMetrics) {\n                    output.explainMetrics = data.explainMetrics;\n                }\n                if (data.document) {\n                    docs.push(data.document);\n                }\n            })\n                .on('end', () => {\n                if (this._queryOptions.limitType === types_1.LimitType.Last) {\n                    // The results for limitToLast queries need to be flipped since\n                    // we reversed the ordering constraints before sending the query\n                    // to the backend.\n                    docs.reverse();\n                }\n                // Only return a snapshot when we have a readTime\n                // explain queries with analyze !== true will return no documents and no read time\n                const result = output.readTime\n                    ? query._createSnapshot(output.readTime, docs.length, () => docs, () => {\n                        const changes = [];\n                        for (let i = 0; i < docs.length; ++i) {\n                            changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n                        }\n                        return changes;\n                    })\n                    : undefined;\n                resolve({\n                    transaction: output.transaction,\n                    explainMetrics: output.explainMetrics,\n                    result,\n                });\n            });\n        });\n    }\n    // This method exists solely to enable unit tests to mock it.\n    _isPermanentRpcError(err, methodName) {\n        return (0, util_1.isPermanentRpcError)(err, methodName);\n    }\n    _hasRetryTimedOut(methodName, startTime) {\n        const totalTimeout = (0, util_1.getTotalTimeout)(methodName);\n        if (totalTimeout === 0) {\n            return false;\n        }\n        return Date.now() - startTime >= totalTimeout;\n    }\n    stream(query) {\n        if (this._queryOptions.limitType === types_1.LimitType.Last) {\n            throw new Error('Query results for queries that include limitToLast() ' +\n                'constraints cannot be streamed. Use Query.get() instead.');\n        }\n        const responseStream = this._stream(query);\n        const transform = new stream_1.Transform({\n            objectMode: true,\n            transform(chunk, encoding, callback) {\n                callback(undefined, chunk.document);\n            },\n        });\n        responseStream.pipe(transform);\n        responseStream.on('error', e => transform.destroy(e));\n        return transform;\n    }\n    _stream(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {\n        const tag = (0, util_1.requestTag)();\n        const startTime = Date.now();\n        const isExplain = explainOptions !== undefined;\n        const methodName = 'runQuery';\n        let numDocumentsReceived = 0;\n        let lastReceivedDocument = null;\n        let backendStream;\n        const stream = new stream_1.Transform({\n            objectMode: true,\n            transform: (proto, enc, callback) => {\n                var _a;\n                if (proto === constants_1.NOOP_MESSAGE) {\n                    callback(undefined);\n                    return;\n                }\n                const output = {};\n                // Proto comes with zero-length buffer by default\n                if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n                    output.transaction = proto.transaction;\n                }\n                if (proto.readTime) {\n                    output.readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n                }\n                if (proto.document) {\n                    const document = this._firestore.snapshot_(proto.document, proto.readTime);\n                    const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));\n                    // Recreate the QueryDocumentSnapshot with the DocumentReference\n                    // containing the original converter.\n                    finalDoc.fieldsProto = document._fieldsProto;\n                    finalDoc.readTime = document.readTime;\n                    finalDoc.createTime = document.createTime;\n                    finalDoc.updateTime = document.updateTime;\n                    lastReceivedDocument = finalDoc.build();\n                    output.document = lastReceivedDocument;\n                }\n                if (proto.explainMetrics) {\n                    output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, this._serializer);\n                }\n                ++numDocumentsReceived;\n                callback(undefined, output);\n                if (proto.done) {\n                    (0, logger_1.logger)('QueryUtil._stream', tag, 'Trigger Logical Termination.');\n                    this._firestore._traceUtil\n                        .currentSpan()\n                        .addEvent(`Firestore.${methodName}: Received RunQueryResponse.Done.`);\n                    backendStream.unpipe(stream);\n                    backendStream.resume();\n                    backendStream.end();\n                    stream.end();\n                }\n            },\n        });\n        this._firestore\n            .initializeIfNeeded(tag)\n            .then(async () => {\n            // `toProto()` might throw an exception. We rely on the behavior of an\n            // async function to convert this exception into the rejected Promise we\n            // catch below.\n            let request = query.toProto(transactionOrReadTime, explainOptions);\n            let isRetryRequestWithCursor = false;\n            let streamActive;\n            do {\n                streamActive = new util_1.Deferred();\n                this._firestore._traceUtil\n                    .currentSpan()\n                    .addEvent(trace_util_1.SPAN_NAME_RUN_QUERY, {\n                    [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: !!request.transaction,\n                    [trace_util_1.ATTRIBUTE_KEY_IS_RETRY_WITH_CURSOR]: isRetryRequestWithCursor,\n                });\n                backendStream = await this._firestore.requestStream(methodName, \n                /* bidirectional= */ false, request, tag);\n                backendStream.on('error', err => {\n                    backendStream.unpipe(stream);\n                    // If a non-transactional query failed, attempt to restart.\n                    // Transactional queries are retried via the transaction runner.\n                    // Explain queries are not retried with a cursor. That would produce\n                    // incorrect/partial profiling results.\n                    if (!isExplain &&\n                        !transactionOrReadTime &&\n                        !this._isPermanentRpcError(err, methodName)) {\n                        (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error:', err);\n                        this._firestore._traceUtil\n                            .currentSpan()\n                            .addEvent(`${trace_util_1.SPAN_NAME_RUN_QUERY}: Retryable Error.`, {\n                            'error.message': err.message,\n                        });\n                        // Enqueue a \"no-op\" write into the stream and wait for it to be\n                        // read by the downstream consumer. This ensures that all enqueued\n                        // results in the stream are consumed, which will give us an accurate\n                        // value for `lastReceivedDocument`.\n                        stream.write(constants_1.NOOP_MESSAGE, () => {\n                            if (this._hasRetryTimedOut(methodName, startTime)) {\n                                (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error but the total retry timeout has exceeded.');\n                                stream.destroy(err);\n                                streamActive.resolve(/* active= */ false);\n                            }\n                            else if (lastReceivedDocument && retryWithCursor) {\n                                if (query instanceof vector_query_1.VectorQuery) {\n                                    throw new Error('Unimplemented: Vector query does not support cursors yet.');\n                                }\n                                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error and progress was made receiving ' +\n                                    'documents, so the stream is being retried.');\n                                isRetryRequestWithCursor = true;\n                                // Restart the query but use the last document we received as\n                                // the query cursor. Note that we do not use backoff here. The\n                                // call to `requestStream()` will backoff should the restart\n                                // fail before delivering any results.\n                                let newQuery;\n                                if (!this._queryOptions.limit) {\n                                    newQuery = query;\n                                }\n                                else {\n                                    const newLimit = this._queryOptions.limit - numDocumentsReceived;\n                                    if (this._queryOptions.limitType === undefined ||\n                                        this._queryOptions.limitType === types_1.LimitType.First) {\n                                        newQuery = query.limit(newLimit);\n                                    }\n                                    else {\n                                        newQuery = query.limitToLast(newLimit);\n                                    }\n                                }\n                                if (this._queryOptions.requireConsistency) {\n                                    request = newQuery\n                                        .startAfter(lastReceivedDocument)\n                                        .toProto(lastReceivedDocument.readTime);\n                                }\n                                else {\n                                    request = newQuery\n                                        .startAfter(lastReceivedDocument)\n                                        .toProto();\n                                }\n                                // Set lastReceivedDocument to null before each retry attempt to ensure the retry makes progress\n                                lastReceivedDocument = null;\n                                streamActive.resolve(/* active= */ true);\n                            }\n                            else {\n                                (0, logger_1.logger)('QueryUtil._stream', tag, `Query failed with retryable stream error however either retryWithCursor=\"${retryWithCursor}\", or ` +\n                                    'no progress was made receiving documents, so the stream is being closed.');\n                                stream.destroy(err);\n                                streamActive.resolve(/* active= */ false);\n                            }\n                        });\n                    }\n                    else {\n                        (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with stream error:', err);\n                        this._firestore._traceUtil\n                            .currentSpan()\n                            .addEvent(`${trace_util_1.SPAN_NAME_RUN_QUERY}: Error.`, {\n                            'error.message': err.message,\n                        });\n                        stream.destroy(err);\n                        streamActive.resolve(/* active= */ false);\n                    }\n                });\n                backendStream.on('end', () => {\n                    streamActive.resolve(/* active= */ false);\n                });\n                backendStream.resume();\n                backendStream.pipe(stream);\n            } while (await streamActive.promise);\n        })\n            .catch(e => stream.destroy(e));\n        return stream;\n    }\n}\nexports.QueryUtil = QueryUtil;\n//# sourceMappingURL=query-util.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}