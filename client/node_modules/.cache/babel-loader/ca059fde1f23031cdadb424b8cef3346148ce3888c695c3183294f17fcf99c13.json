{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryable = retryable;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\nfunction retryable(func, retry, otherArgs, apiName) {\n  const delayMult = retry.backoffSettings.retryDelayMultiplier;\n  const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  let delay = retry.backoffSettings.initialRetryDelayMillis;\n  let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\n   * Equivalent to ``func``, but retries upon transient failure.\n   *\n   * Retrying is done through an exponential backoff algorithm configured\n   * by the options in ``retry``.\n   * @param {RequestType} argument The request object.\n   * @param {APICallback} callback The callback.\n   * @return {GRPCCall}\n   */\n  return (argument, callback) => {\n    let canceller;\n    let timeoutId;\n    let now = new Date();\n    let deadline;\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n    let retries = 0;\n    const maxRetries = retry.backoffSettings.maxRetries;\n    // TODO: define A/B testing values for retry behaviors.\n    /** Repeat the API call as long as necessary. */\n    function repeat(err) {\n      timeoutId = null;\n      if (deadline && now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds ${err ? `retrying error ${err} ` : ''} before any response was received.`);\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n      if (retries && retries >= maxRetries) {\n        const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' + (err ? `retrying error ${err} ` : '') + 'before any response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n      retries++;\n      let lastError = err;\n      const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\n      canceller = toCall(argument, (err, response, next, rawResponse) => {\n        // Save only the error before deadline exceeded\n        if (err && err.code !== 4) {\n          lastError = err;\n        }\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n        canceller = null;\n        if (retry.retryCodes.length > 0 && retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          const toSleep = Math.random() * delay;\n          timeoutId = setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n            const rpcTimeout = maxTimeout ? maxTimeout : 0;\n            const newDeadline = deadline ? deadline - now.getTime() : 0;\n            timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            repeat(lastError);\n          }, toSleep);\n        }\n      });\n      if (canceller instanceof Promise) {\n        canceller.catch(err => {\n          callback(new googleError_1.GoogleError(err));\n        });\n      }\n    }\n    if (maxRetries && deadline) {\n      const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n    } else {\n      repeat();\n    }\n    return {\n      cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          const error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n          callback(error);\n        }\n      }\n    };\n  };\n}","map":{"version":3,"names":["exports","retryable","status_1","require","googleError_1","timeout_1","func","retry","otherArgs","apiName","delayMult","backoffSettings","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","timeout","initialRpcTimeoutMillis","argument","callback","canceller","timeoutId","now","Date","deadline","totalTimeoutMillis","getTime","retries","maxRetries","repeat","err","error","GoogleError","code","Status","DEADLINE_EXCEEDED","lastError","toCall","addTimeoutArg","response","next","rawResponse","retryCodes","length","indexOf","note","toSleep","Math","random","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","Promise","catch","INVALID_ARGUMENT","cancel","clearTimeout","CANCELLED"],"sources":["../../../src/normalCalls/retries.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}